(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/jquery-timepicker/jquery-timepicker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/jquery-timepicker/jquery-timepicker.js":
/*!*****************************************************!*\
  !*** ./libs/jquery-timepicker/jquery-timepicker.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var timepicker_jquery_timepicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timepicker/jquery.timepicker */ \"./node_modules/timepicker/jquery.timepicker.js\");\n/* harmony import */ var timepicker_jquery_timepicker__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(timepicker_jquery_timepicker__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL2pxdWVyeS10aW1lcGlja2VyL2pxdWVyeS10aW1lcGlja2VyLmpzPzgxMDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwiZmlsZSI6Ii4vbGlicy9qcXVlcnktdGltZXBpY2tlci9qcXVlcnktdGltZXBpY2tlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAndGltZXBpY2tlci9qcXVlcnkudGltZXBpY2tlcic7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/jquery-timepicker/jquery-timepicker.js\n");

/***/ }),

/***/ "./node_modules/timepicker/jquery.timepicker.js":
/*!******************************************************!*\
  !*** ./node_modules/timepicker/jquery.timepicker.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jquery-timepicker v1.13.18 - A jQuery timepicker plugin inspired by Google Calendar. It supports both mouse and keyboard navigation.\n * Copyright (c) 2021 Jon Thornton - https://www.jonthornton.com/jquery-timepicker/\n * License: MIT\n */\n(function () {\n  'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = o[Symbol.iterator]();\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  var ONE_DAY = 86400;\n\n  var roundingFunction = function roundingFunction(seconds, settings) {\n    if (seconds === null) {\n      return null;\n    } else if (typeof settings.step !== \"number\") {\n      // TODO: nearest fit irregular steps\n      return seconds;\n    } else {\n      var _settings$minTime;\n\n      var offset = seconds % (settings.step * 60); // step is in minutes\n\n      var start = (_settings$minTime = settings.minTime()) !== null && _settings$minTime !== void 0 ? _settings$minTime : 0; // adjust offset by start mod step so that the offset is aligned not to 00:00 but to the start\n\n      offset -= start % (settings.step * 60);\n\n      if (offset >= settings.step * 30) {\n        // if offset is larger than a half step, round up\n        seconds += settings.step * 60 - offset;\n      } else {\n        // round down\n        seconds -= offset;\n      }\n\n      return _moduloSeconds(seconds, settings);\n    }\n  };\n\n  function _moduloSeconds(seconds, settings) {\n    if (seconds == ONE_DAY && settings.show2400) {\n      return seconds;\n    }\n\n    return seconds % ONE_DAY;\n  }\n\n  var DEFAULT_SETTINGS = {\n    appendTo: \"body\",\n    className: null,\n    closeOnWindowScroll: false,\n    disableTextInput: false,\n    disableTimeRanges: [],\n    disableTouchKeyboard: false,\n    durationTime: null,\n    forceRoundTime: false,\n    lang: {},\n    listWidth: null,\n    maxTime: null,\n    minTime: null,\n    noneOption: false,\n    orientation: \"l\",\n    roundingFunction: roundingFunction,\n    scrollDefault: null,\n    selectOnBlur: false,\n    show2400: false,\n    showDuration: false,\n    showOn: [\"click\", \"focus\"],\n    showOnFocus: true,\n    step: 30,\n    stopScrollPropagation: false,\n    timeFormat: \"g:ia\",\n    typeaheadHighlight: true,\n    useSelect: false,\n    wrapHours: true\n  };\n  var DEFAULT_LANG = {\n    am: \"am\",\n    pm: \"pm\",\n    AM: \"AM\",\n    PM: \"PM\",\n    decimal: \".\",\n    mins: \"mins\",\n    hr: \"hr\",\n    hrs: \"hrs\"\n  };\n\n  var EVENT_DEFAULTS = {\n    bubbles: true,\n    cancelable: false,\n    detail: null\n  };\n\n  var Timepicker = /*#__PURE__*/function () {\n    function Timepicker(targetEl) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Timepicker);\n\n      this._handleFormatValue = this._handleFormatValue.bind(this);\n      this._handleKeyUp = this._handleKeyUp.bind(this);\n      this.targetEl = targetEl;\n      var attrOptions = Timepicker.extractAttrOptions(targetEl, Object.keys(DEFAULT_SETTINGS));\n      this.settings = this.parseSettings(_objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SETTINGS), options), attrOptions));\n    }\n\n    _createClass(Timepicker, [{\n      key: \"hideMe\",\n      value: function hideMe() {\n        if (this.settings.useSelect) {\n          this.targetEl.blur();\n          return;\n        }\n\n        if (!this.list || !Timepicker.isVisible(this.list)) {\n          return;\n        }\n\n        if (this.settings.selectOnBlur) {\n          this._selectValue();\n        }\n\n        this.list.hide();\n        var hideTimepickerEvent = new CustomEvent('hideTimepicker', EVENT_DEFAULTS);\n        this.targetEl.dispatchEvent(hideTimepickerEvent);\n      }\n    }, {\n      key: \"_findRow\",\n      value: function _findRow(value) {\n        if (!value && value !== 0) {\n          return false;\n        }\n\n        var out = false;\n        var value = this.settings.roundingFunction(value, this.settings);\n\n        if (!this.list) {\n          return false;\n        }\n\n        this.list.find(\"li\").each(function (i, obj) {\n          var parsed = parseInt(obj.dataset.time);\n\n          if (isNaN(parsed)) {\n            return;\n          }\n\n          if (parsed == value) {\n            out = obj;\n            return false;\n          }\n        });\n        return out;\n      }\n    }, {\n      key: \"_hideKeyboard\",\n      value: function _hideKeyboard() {\n        return (window.navigator.msMaxTouchPoints || \"ontouchstart\" in document) && this.settings.disableTouchKeyboard;\n      }\n    }, {\n      key: \"_setTimeValue\",\n      value: function _setTimeValue(value, source) {\n        if (this.targetEl.nodeName === \"INPUT\") {\n          if (value !== null || this.targetEl.value != \"\") {\n            this.targetEl.value = value;\n          }\n\n          var tp = this;\n          var settings = tp.settings;\n\n          if (settings.useSelect && source != \"select\" && tp.list) {\n            tp.list.val(tp._roundAndFormatTime(tp.anytime2int(value)));\n          }\n        }\n\n        var selectTimeEvent = new CustomEvent('selectTime', EVENT_DEFAULTS);\n\n        if (this.selectedValue != value) {\n          this.selectedValue = value;\n          var changeTimeEvent = new CustomEvent('changeTime', EVENT_DEFAULTS);\n          var changeEvent = new CustomEvent('change', Object.assign(EVENT_DEFAULTS, {\n            detail: 'timepicker'\n          }));\n\n          if (source == \"select\") {\n            this.targetEl.dispatchEvent(selectTimeEvent);\n            this.targetEl.dispatchEvent(changeTimeEvent);\n            this.targetEl.dispatchEvent(changeEvent);\n          } else if ([\"error\", \"initial\"].indexOf(source) == -1) {\n            this.targetEl.dispatchEvent(changeTimeEvent);\n          }\n\n          return true;\n        } else {\n          if ([\"error\", \"initial\"].indexOf(source) == -1) {\n            this.targetEl.dispatchEvent(selectTimeEvent);\n          }\n\n          return false;\n        }\n      }\n    }, {\n      key: \"_getTimeValue\",\n      value: function _getTimeValue() {\n        if (this.targetEl.nodeName === \"INPUT\") {\n          return this.targetEl.value;\n        } else {\n          // use the element's data attributes to store values\n          return this.selectedValue;\n        }\n      }\n    }, {\n      key: \"_selectValue\",\n      value: function _selectValue() {\n        var tp = this;\n        tp.settings;\n        var list = tp.list;\n        var cursor = list.find(\".ui-timepicker-selected\");\n\n        if (cursor.hasClass(\"ui-timepicker-disabled\")) {\n          return false;\n        }\n\n        if (!cursor.length) {\n          return true;\n        }\n\n        var timeValue = cursor.get(0).dataset.time; // selected value found\n\n        if (timeValue) {\n          var parsedTimeValue = parseInt(timeValue);\n\n          if (!isNaN(parsedTimeValue)) {\n            timeValue = parsedTimeValue;\n          }\n        }\n\n        if (timeValue !== null) {\n          if (typeof timeValue != \"string\") {\n            timeValue = tp._int2time(timeValue);\n          }\n\n          tp._setTimeValue(timeValue, \"select\");\n        }\n\n        return true;\n      }\n    }, {\n      key: \"anytime2int\",\n      value: function anytime2int(input) {\n        if (typeof input === 'number') {\n          return input;\n        } else if (typeof input === 'string') {\n          return this.time2int(input);\n        } else if (_typeof(input) === 'object' && input instanceof Date) {\n          return input.getHours() * 3600 + input.getMinutes() * 60 + input.getSeconds();\n        } else if (typeof input == 'function') {\n          return input();\n        } else {\n          return null;\n        }\n      }\n    }, {\n      key: \"time2int\",\n      value: function time2int(timeString) {\n        if (timeString === \"\" || timeString === null || timeString === undefined) {\n          return null;\n        }\n\n        if (timeString === 'now') {\n          return this.anytime2int(new Date());\n        }\n\n        if (typeof timeString != \"string\") {\n          return timeString;\n        }\n\n        timeString = timeString.toLowerCase().replace(/[\\s\\.]/g, \"\"); // if the last character is an \"a\" or \"p\", add the \"m\"\n\n        if (timeString.slice(-1) == \"a\" || timeString.slice(-1) == \"p\") {\n          timeString += \"m\";\n        }\n\n        var pattern = /^(([^0-9]*))?([0-9]?[0-9])(([0-5][0-9]))?(([0-5][0-9]))?(([^0-9]*))$/;\n        var hasDelimetersMatch = timeString.match(/\\W/);\n\n        if (hasDelimetersMatch) {\n          pattern = /^(([^0-9]*))?([0-9]?[0-9])(\\W+([0-5][0-9]?))?(\\W+([0-5][0-9]))?(([^0-9]*))$/;\n        }\n\n        var time = timeString.match(pattern);\n\n        if (!time) {\n          return null;\n        }\n\n        var hour = parseInt(time[3] * 1, 10);\n        var ampm = time[2] || time[9];\n        var hours = hour;\n        var minutes = time[5] * 1 || 0;\n        var seconds = time[7] * 1 || 0;\n\n        if (!ampm && time[3].length == 2 && time[3][0] == \"0\") {\n          // preceding '0' implies AM\n          ampm = \"am\";\n        }\n\n        if (hour <= 12 && ampm) {\n          ampm = ampm.trim();\n          var isPm = ampm == this.settings.lang.pm || ampm == this.settings.lang.PM;\n\n          if (hour == 12) {\n            hours = isPm ? 12 : 0;\n          } else {\n            hours = hour + (isPm ? 12 : 0);\n          }\n        } else {\n          var t = hour * 3600 + minutes * 60 + seconds;\n\n          if (t >= ONE_DAY + (this.settings.show2400 ? 1 : 0)) {\n            if (this.settings.wrapHours === false) {\n              return null;\n            }\n\n            hours = hour % 24;\n          }\n        }\n\n        var timeInt = hours * 3600 + minutes * 60 + seconds; // if no am/pm provided, intelligently guess based on the scrollDefault\n\n        if (hour < 12 && !ampm && this.settings._twelveHourTime && this.settings.scrollDefault()) {\n          var delta = timeInt - this.settings.scrollDefault();\n\n          if (delta < 0 && delta >= ONE_DAY / -2) {\n            timeInt = (timeInt + ONE_DAY / 2) % ONE_DAY;\n          }\n        }\n\n        return timeInt;\n      }\n    }, {\n      key: \"intStringDateOrFunc2func\",\n      value: function intStringDateOrFunc2func(input) {\n        var _this = this;\n\n        if (input === null || input === undefined) {\n          return function () {\n            return null;\n          };\n        } else if (typeof input === 'function') {\n          return function () {\n            return _this.anytime2int(input());\n          };\n        } else {\n          return function () {\n            return _this.anytime2int(input);\n          };\n        }\n      }\n    }, {\n      key: \"parseSettings\",\n      value: function parseSettings(settings) {\n        settings.lang = _objectSpread2(_objectSpread2({}, DEFAULT_LANG), settings.lang); // lang is used by other functions the rest of this depends on\n        // todo: unwind circular dependency on lang\n\n        this.settings = settings;\n\n        if (settings.listWidth) {\n          settings.listWidth = this.anytime2int(settings.listWidth);\n        }\n\n        settings.minTime = this.intStringDateOrFunc2func(settings.minTime);\n        settings.maxTime = this.intStringDateOrFunc2func(settings.maxTime);\n        settings.durationTime = this.intStringDateOrFunc2func(settings.durationTime);\n\n        if (settings.scrollDefault) {\n          settings.scrollDefault = this.intStringDateOrFunc2func(settings.scrollDefault);\n        } else {\n          settings.scrollDefault = settings.minTime;\n        }\n\n        if (typeof settings.timeFormat === \"string\" && settings.timeFormat.match(/[gh]/)) {\n          settings._twelveHourTime = true;\n        }\n\n        if (settings.showOnFocus === false && settings.showOn.indexOf(\"focus\") != -1) {\n          settings.showOn.splice(settings.showOn.indexOf(\"focus\"), 1);\n        }\n\n        if (!settings.disableTimeRanges) {\n          settings.disableTimeRanges = [];\n        }\n\n        if (settings.disableTimeRanges.length > 0) {\n          // convert string times to integers\n          for (var i in settings.disableTimeRanges) {\n            settings.disableTimeRanges[i] = [this.anytime2int(settings.disableTimeRanges[i][0]), this.anytime2int(settings.disableTimeRanges[i][1])];\n          } // sort by starting time\n\n\n          settings.disableTimeRanges = settings.disableTimeRanges.sort(function (a, b) {\n            return a[0] - b[0];\n          }); // merge any overlapping ranges\n\n          for (var i = settings.disableTimeRanges.length - 1; i > 0; i--) {\n            if (settings.disableTimeRanges[i][0] <= settings.disableTimeRanges[i - 1][1]) {\n              settings.disableTimeRanges[i - 1] = [Math.min(settings.disableTimeRanges[i][0], settings.disableTimeRanges[i - 1][0]), Math.max(settings.disableTimeRanges[i][1], settings.disableTimeRanges[i - 1][1])];\n              settings.disableTimeRanges.splice(i, 1);\n            }\n          }\n        }\n\n        return settings;\n      }\n      /*\n       *  Filter freeform input\n       */\n\n    }, {\n      key: \"_disableTextInputHandler\",\n      value: function _disableTextInputHandler(e) {\n        switch (e.keyCode) {\n          case 13: // return\n\n          case 9:\n            //tab\n            return;\n\n          default:\n            e.preventDefault();\n        }\n      }\n    }, {\n      key: \"_int2duration\",\n      value: function _int2duration(seconds, step) {\n        seconds = Math.abs(seconds);\n        var minutes = Math.round(seconds / 60),\n            duration = [],\n            hours,\n            mins;\n\n        if (minutes < 60) {\n          // Only show (x mins) under 1 hour\n          duration = [minutes, this.settings.lang.mins];\n        } else {\n          hours = Math.floor(minutes / 60);\n          mins = minutes % 60; // Show decimal notation (eg: 1.5 hrs) for 30 minute steps\n\n          if (step == 30 && mins == 30) {\n            hours += this.settings.lang.decimal + 5;\n          }\n\n          duration.push(hours);\n          duration.push(hours == 1 ? this.settings.lang.hr : this.settings.lang.hrs); // Show remainder minutes notation (eg: 1 hr 15 mins) for non-30 minute steps\n          // and only if there are remainder minutes to show\n\n          if (step != 30 && mins) {\n            duration.push(mins);\n            duration.push(this.settings.lang.mins);\n          }\n        }\n\n        return duration.join(\" \");\n      }\n    }, {\n      key: \"_roundAndFormatTime\",\n      value: function _roundAndFormatTime(seconds) {\n        seconds = this.settings.roundingFunction(seconds, this.settings);\n\n        if (seconds !== null) {\n          return this._int2time(seconds);\n        }\n      }\n    }, {\n      key: \"_int2time\",\n      value: function _int2time(timeInt) {\n        if (typeof timeInt != \"number\") {\n          return null;\n        }\n\n        var seconds = parseInt(timeInt % 60),\n            minutes = parseInt(timeInt / 60 % 60),\n            hours = parseInt(timeInt / (60 * 60) % 24);\n        var time = new Date(1970, 0, 2, hours, minutes, seconds, 0);\n\n        if (isNaN(time.getTime())) {\n          return null;\n        }\n\n        if (typeof this.settings.timeFormat === \"function\") {\n          return this.settings.timeFormat(time);\n        }\n\n        var output = \"\";\n        var hour, code;\n\n        for (var i = 0; i < this.settings.timeFormat.length; i++) {\n          code = this.settings.timeFormat.charAt(i);\n\n          switch (code) {\n            case \"a\":\n              output += time.getHours() > 11 ? this.settings.lang.pm : this.settings.lang.am;\n              break;\n\n            case \"A\":\n              output += time.getHours() > 11 ? this.settings.lang.PM : this.settings.lang.AM;\n              break;\n\n            case \"g\":\n              hour = time.getHours() % 12;\n              output += hour === 0 ? \"12\" : hour;\n              break;\n\n            case \"G\":\n              hour = time.getHours();\n              if (timeInt === ONE_DAY) hour = this.settings.show2400 ? 24 : 0;\n              output += hour;\n              break;\n\n            case \"h\":\n              hour = time.getHours() % 12;\n\n              if (hour !== 0 && hour < 10) {\n                hour = \"0\" + hour;\n              }\n\n              output += hour === 0 ? \"12\" : hour;\n              break;\n\n            case \"H\":\n              hour = time.getHours();\n              if (timeInt === ONE_DAY) hour = this.settings.show2400 ? 24 : 0;\n              output += hour > 9 ? hour : \"0\" + hour;\n              break;\n\n            case \"i\":\n              var minutes = time.getMinutes();\n              output += minutes > 9 ? minutes : \"0\" + minutes;\n              break;\n\n            case \"s\":\n              seconds = time.getSeconds();\n              output += seconds > 9 ? seconds : \"0\" + seconds;\n              break;\n\n            case \"\\\\\":\n              // escape character; add the next character and skip ahead\n              i++;\n              output += this.settings.timeFormat.charAt(i);\n              break;\n\n            default:\n              output += code;\n          }\n        }\n\n        return output;\n      }\n    }, {\n      key: \"_setSelected\",\n      value: function _setSelected() {\n        var list = this.list;\n        list.find(\"li\").removeClass(\"ui-timepicker-selected\");\n        var timeValue = this.anytime2int(this._getTimeValue());\n\n        if (timeValue === null) {\n          return;\n        }\n\n        var selected = this._findRow(timeValue);\n\n        if (selected) {\n          var selectedRect = selected.getBoundingClientRect();\n          var listRect = list.get(0).getBoundingClientRect();\n          var topDelta = selectedRect.top - listRect.top;\n\n          if (topDelta + selectedRect.height > listRect.height || topDelta < 0) {\n            var newScroll = list.scrollTop() + (selectedRect.top - listRect.top) - selectedRect.height;\n            list.scrollTop(newScroll);\n          }\n\n          var parsed = parseInt(selected.dataset.time);\n\n          if (this.settings.forceRoundTime || parsed === timeValue) {\n            selected.classList.add('ui-timepicker-selected');\n          }\n        }\n      }\n    }, {\n      key: \"_isFocused\",\n      value: function _isFocused(el) {\n        return el === document.activeElement;\n      }\n    }, {\n      key: \"_handleFormatValue\",\n      value: function _handleFormatValue(e) {\n        if (e && e.detail == \"timepicker\") {\n          return;\n        }\n\n        this._formatValue(e);\n      }\n    }, {\n      key: \"_formatValue\",\n      value: function _formatValue(e, origin) {\n        if (this.targetEl.value === \"\") {\n          this._setTimeValue(null, origin);\n\n          return;\n        } // IE fires change event before blur\n\n\n        if (this._isFocused(this.targetEl) && (!e || e.type != \"change\")) {\n          return;\n        }\n\n        var settings = this.settings;\n        var seconds = this.anytime2int(this.targetEl.value);\n\n        if (seconds === null) {\n          var timeFormatErrorEvent = new CustomEvent('timeFormatError', EVENT_DEFAULTS);\n          this.targetEl.dispatchEvent(timeFormatErrorEvent);\n          return;\n        }\n\n        var rangeError = false; // check that the time in within bounds\n\n        if (settings.minTime !== null && settings.maxTime !== null && (seconds < settings.minTime() || seconds > settings.maxTime())) {\n          rangeError = true;\n        } // check that time isn't within disabled time ranges\n\n\n        var _iterator = _createForOfIteratorHelper(settings.disableTimeRanges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var range = _step.value;\n\n            if (seconds >= range[0] && seconds < range[1]) {\n              rangeError = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (settings.forceRoundTime) {\n          var roundSeconds = settings.roundingFunction(seconds, settings);\n\n          if (roundSeconds != seconds) {\n            seconds = roundSeconds;\n            origin = null;\n          }\n        }\n\n        var prettyTime = this._int2time(seconds);\n\n        if (rangeError) {\n          this._setTimeValue(prettyTime);\n\n          var timeRangeErrorEvent = new CustomEvent('timeRangeError', EVENT_DEFAULTS);\n          this.targetEl.dispatchEvent(timeRangeErrorEvent);\n        } else {\n          this._setTimeValue(prettyTime, origin);\n        }\n      }\n    }, {\n      key: \"_generateNoneElement\",\n      value: function _generateNoneElement(optionValue, useSelect) {\n        var label, className, value;\n\n        if (_typeof(optionValue) == \"object\") {\n          label = optionValue.label;\n          className = optionValue.className;\n          value = optionValue.value;\n        } else if (typeof optionValue == \"string\") {\n          label = optionValue;\n          value = \"\";\n        } else {\n          $.error(\"Invalid noneOption value\");\n        }\n\n        var el;\n\n        if (useSelect) {\n          el = document.createElement(\"option\");\n          el.value = value;\n        } else {\n          el = document.createElement(\"li\");\n          el.dataset.time = String(value);\n        }\n\n        el.innerText = label;\n        el.classList.add(className);\n        return el;\n      }\n      /*\n       *  Time typeahead\n       */\n\n    }, {\n      key: \"_handleKeyUp\",\n      value: function _handleKeyUp(e) {\n        var _this2 = this;\n\n        if (!this.list || !Timepicker.isVisible(this.list) || this.settings.disableTextInput) {\n          return true;\n        }\n\n        if (e.type === \"paste\" || e.type === \"cut\") {\n          var handler = function handler() {\n            if (_this2.settings.typeaheadHighlight) {\n              _this2._setSelected();\n            } else {\n              _this2.list.hide();\n            }\n          };\n\n          setTimeout(handler, 0);\n          return;\n        }\n\n        switch (e.keyCode) {\n          case 96: // numpad numerals\n\n          case 97:\n          case 98:\n          case 99:\n          case 100:\n          case 101:\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n          case 48: // numerals\n\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n          case 65: // a\n\n          case 77: // m\n\n          case 80: // p\n\n          case 186: // colon\n\n          case 8: // backspace\n\n          case 46:\n            // delete\n            if (this.settings.typeaheadHighlight) {\n              this._setSelected();\n            } else {\n              this.list.hide();\n            }\n\n            break;\n        }\n      }\n    }], [{\n      key: \"extractAttrOptions\",\n      value: function extractAttrOptions(element, keys) {\n        var output = {};\n\n        var _iterator2 = _createForOfIteratorHelper(keys),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n\n            if (key in element.dataset) {\n              output[key] = element.dataset[key];\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return output;\n      }\n    }, {\n      key: \"isVisible\",\n      value: function isVisible(elem) {\n        var el = elem[0];\n        return el.offsetWidth > 0 && el.offsetHeight > 0;\n      }\n    }, {\n      key: \"hideAll\",\n      value: function hideAll() {\n        var _iterator3 = _createForOfIteratorHelper(document.getElementsByClassName('ui-timepicker-input')),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var el = _step3.value;\n            var tp = el.timepickerObj;\n\n            if (tp) {\n              tp.hideMe();\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }]);\n\n    return Timepicker;\n  }(); // IE9-11 polyfill for CustomEvent\n\n\n  (function () {\n    if (typeof window.CustomEvent === \"function\") return false;\n\n    function CustomEvent(event, params) {\n      if (!params) {\n        params = {};\n      }\n\n      params = Object.assign(EVENT_DEFAULTS, params);\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    window.CustomEvent = CustomEvent;\n  })();\n\n  (function (factory) {\n    if (( false ? undefined : _typeof(exports)) === \"object\" && exports && ( false ? undefined : _typeof(module)) === \"object\" && module && module.exports === exports) {\n      // Browserify. Attach to jQuery module.\n      factory(__webpack_require__(/*! jquery */ \"jquery\"));\n    } else if (true) {\n      // AMD. Register as an anonymous module.\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n  })(function ($) {\n    var methods = {\n      init: function init(options) {\n        return this.each(function () {\n          var self = $(this);\n          var tp = new Timepicker(this, options);\n          var settings = tp.settings;\n          settings.lang;\n          this.timepickerObj = tp;\n          self.addClass(\"ui-timepicker-input\");\n\n          if (settings.useSelect) {\n            _render(self);\n          } else {\n            self.prop(\"autocomplete\", \"off\");\n\n            if (settings.showOn) {\n              for (var i in settings.showOn) {\n                self.on(settings.showOn[i] + \".timepicker\", methods.show);\n              }\n            }\n\n            self.on(\"change.timepicker\", tp._handleFormatValue);\n            self.on(\"keydown.timepicker\", _keydownhandler);\n            self.on(\"keyup.timepicker\", tp._handleKeyUp);\n\n            if (settings.disableTextInput) {\n              self.on(\"keydown.timepicker\", tp._disableTextInputHandler);\n            }\n\n            self.on(\"cut.timepicker\", tp._handleKeyUp);\n            self.on(\"paste.timepicker\", tp._handleKeyUp);\n\n            tp._formatValue(null, \"initial\");\n          }\n        });\n      },\n      show: function show(e) {\n        var self = $(this);\n        var tp = self[0].timepickerObj;\n        var settings = tp.settings;\n\n        if (e) {\n          e.preventDefault();\n        }\n\n        if (settings.useSelect) {\n          tp.list.trigger('focus');\n          return;\n        }\n\n        if (tp._hideKeyboard()) {\n          // block the keyboard on mobile devices\n          self.trigger('blur');\n        }\n\n        var list = tp.list; // check if input is readonly\n\n        if (self.prop(\"readonly\")) {\n          return;\n        } // check if list needs to be rendered\n\n\n        _render(self);\n\n        list = tp.list;\n\n        if (Timepicker.isVisible(list)) {\n          return;\n        }\n\n        if (self.is('input')) {\n          tp.selectedValue = self.val();\n        }\n\n        tp._setSelected(); // make sure other pickers are hidden\n\n\n        Timepicker.hideAll();\n\n        if (typeof settings.listWidth == \"number\") {\n          list.width(self.outerWidth() * settings.listWidth);\n        } // position the dropdown relative to the input\n\n\n        list.show();\n        var listOffset = {};\n\n        if (settings.orientation.match(/r/)) {\n          // right-align the dropdown\n          listOffset.left = self.offset().left + self.outerWidth() - list.outerWidth() + parseInt(list.css(\"marginLeft\").replace(\"px\", \"\"), 10);\n        } else if (settings.orientation.match(/l/)) {\n          // left-align the dropdown\n          listOffset.left = self.offset().left + parseInt(list.css(\"marginLeft\").replace(\"px\", \"\"), 10);\n        } else if (settings.orientation.match(/c/)) {\n          // center-align the dropdown\n          listOffset.left = self.offset().left + (self.outerWidth() - list.outerWidth()) / 2 + parseInt(list.css(\"marginLeft\").replace(\"px\", \"\"), 10);\n        }\n\n        var verticalOrientation;\n\n        if (settings.orientation.match(/t/)) {\n          verticalOrientation = \"t\";\n        } else if (settings.orientation.match(/b/)) {\n          verticalOrientation = \"b\";\n        } else if (self.offset().top + self.outerHeight(true) + list.outerHeight() > $(window).height() + $(window).scrollTop()) {\n          verticalOrientation = \"t\";\n        } else {\n          verticalOrientation = \"b\";\n        }\n\n        if (verticalOrientation == \"t\") {\n          // position the dropdown on top\n          list.addClass(\"ui-timepicker-positioned-top\");\n          listOffset.top = self.offset().top - list.outerHeight() + parseInt(list.css(\"marginTop\").replace(\"px\", \"\"), 10);\n        } else {\n          // put it under the input\n          list.removeClass(\"ui-timepicker-positioned-top\");\n          listOffset.top = self.offset().top + self.outerHeight() + parseInt(list.css(\"marginTop\").replace(\"px\", \"\"), 10);\n        }\n\n        list.offset(listOffset); // position scrolling\n\n        var selected = list.find(\".ui-timepicker-selected\");\n\n        if (!selected.length) {\n          var timeInt = tp.anytime2int(tp._getTimeValue());\n\n          if (timeInt !== null) {\n            selected = $(tp._findRow(timeInt));\n          } else if (settings.scrollDefault()) {\n            selected = $(tp._findRow(settings.scrollDefault()));\n          }\n        } // if not found or disabled, intelligently find first selectable element\n\n\n        if (!selected.length || selected.hasClass(\"ui-timepicker-disabled\")) {\n          selected = list.find(\"li:not(.ui-timepicker-disabled):first\");\n        }\n\n        if (selected && selected.length) {\n          var topOffset = list.scrollTop() + selected.position().top - selected.outerHeight();\n          list.scrollTop(topOffset);\n        } else {\n          list.scrollTop(0);\n        } // prevent scroll propagation\n\n\n        if (settings.stopScrollPropagation) {\n          $(document).on(\"wheel.ui-timepicker\", \".ui-timepicker-wrapper\", function (e) {\n            e.preventDefault();\n            var currentScroll = $(this).scrollTop();\n            $(this).scrollTop(currentScroll + e.originalEvent.deltaY);\n          });\n        } // attach close handlers\n\n\n        $(document).on(\"mousedown.ui-timepicker\", _closeHandler);\n        window.addEventListener('resize', _closeHandler);\n\n        if (settings.closeOnWindowScroll) {\n          $(document).on(\"scroll.ui-timepicker\", _closeHandler);\n        }\n\n        self.trigger(\"showTimepicker\");\n        return this;\n      },\n      hide: function hide(e) {\n        var tp = this[0].timepickerObj;\n\n        if (tp) {\n          tp.hideMe();\n        }\n\n        Timepicker.hideAll();\n        return this;\n      },\n      option: function option(key, value) {\n        if (typeof key == \"string\" && typeof value == \"undefined\") {\n          var tp = this[0].timepickerObj;\n          return tp.settings[key];\n        }\n\n        return this.each(function () {\n          var self = $(this);\n          var tp = self[0].timepickerObj;\n          var settings = tp.settings;\n          var list = tp.list;\n\n          if (_typeof(key) == \"object\") {\n            settings = $.extend(settings, key);\n          } else if (typeof key == \"string\") {\n            settings[key] = value;\n          }\n\n          settings = tp.parseSettings(settings);\n          tp.settings = settings;\n\n          tp._formatValue({\n            type: \"change\"\n          }, \"initial\");\n\n          if (list) {\n            list.remove();\n            tp.list = null;\n          }\n\n          if (settings.useSelect) {\n            _render(self);\n          }\n        });\n      },\n      getSecondsFromMidnight: function getSecondsFromMidnight() {\n        var tp = this[0].timepickerObj;\n        return tp.anytime2int(tp._getTimeValue());\n      },\n      getTime: function getTime(relative_date) {\n        var tp = this[0].timepickerObj;\n\n        var time_string = tp._getTimeValue();\n\n        if (!time_string) {\n          return null;\n        }\n\n        var offset = tp.anytime2int(time_string);\n\n        if (offset === null) {\n          return null;\n        }\n\n        if (!relative_date) {\n          relative_date = new Date();\n        } // construct a Date from relative date, and offset's time\n\n\n        var time = new Date(relative_date);\n        time.setHours(offset / 3600);\n        time.setMinutes(offset % 3600 / 60);\n        time.setSeconds(offset % 60);\n        time.setMilliseconds(0);\n        return time;\n      },\n      isVisible: function isVisible() {\n        var tp = this[0].timepickerObj;\n        return !!(tp && tp.list && Timepicker.isVisible(tp.list));\n      },\n      setTime: function setTime(value) {\n        var tp = this[0].timepickerObj;\n        var settings = tp.settings;\n\n        if (settings.forceRoundTime) {\n          var prettyTime = tp._roundAndFormatTime(tp.anytime2int(value));\n        } else {\n          var prettyTime = tp._int2time(tp.anytime2int(value));\n        }\n\n        if (value && prettyTime === null && settings.noneOption) {\n          prettyTime = value;\n        }\n\n        tp._setTimeValue(prettyTime, \"initial\");\n\n        tp._formatValue({\n          type: \"change\"\n        }, \"initial\");\n\n        if (tp && tp.list) {\n          tp._setSelected();\n        }\n\n        return this;\n      },\n      remove: function remove() {\n        var self = this; // check if this element is a timepicker\n\n        if (!self.hasClass(\"ui-timepicker-input\")) {\n          return;\n        }\n\n        var tp = self[0].timepickerObj;\n        var settings = tp.settings;\n        self.removeAttr(\"autocomplete\", \"off\");\n        self.removeClass(\"ui-timepicker-input\");\n        self.removeData(\"timepicker-obj\");\n        self.off(\".timepicker\"); // timepicker-list won't be present unless the user has interacted with this timepicker\n\n        if (tp.list) {\n          tp.list.remove();\n        }\n\n        if (settings.useSelect) {\n          self.show();\n        }\n\n        tp.list = null;\n        return this;\n      }\n    }; // private methods\n\n    function _render(self) {\n      var _settings$durationTim, _settings$minTime, _settings$maxTime;\n\n      var tp = self[0].timepickerObj;\n      var list = tp.list;\n      var settings = tp.settings;\n\n      if (list && list.length) {\n        list.remove();\n        tp.list = null;\n      }\n\n      if (settings.useSelect) {\n        list = $(\"<select></select>\", {\n          \"class\": \"ui-timepicker-select\"\n        });\n\n        if (self.attr(\"name\")) {\n          list.attr(\"name\", \"ui-timepicker-\" + self.attr(\"name\"));\n        }\n\n        var wrapped_list = list;\n      } else {\n        list = $(\"<ul></ul>\", {\n          \"class\": \"ui-timepicker-list\"\n        });\n        var wrapped_list = $(\"<div></div>\", {\n          \"class\": \"ui-timepicker-wrapper\",\n          tabindex: -1\n        });\n        wrapped_list.css({\n          display: \"none\",\n          position: \"absolute\"\n        }).append(list);\n      }\n\n      if (settings.noneOption) {\n        if (settings.noneOption === true) {\n          settings.noneOption = settings.useSelect ? \"Time...\" : \"None\";\n        }\n\n        if ($.isArray(settings.noneOption)) {\n          for (var i in settings.noneOption) {\n            if (parseInt(i, 10) == i) {\n              var noneElement = tp._generateNoneElement(settings.noneOption[i], settings.useSelect);\n\n              list.append(noneElement);\n            }\n          }\n        } else {\n          var noneElement = tp._generateNoneElement(settings.noneOption, settings.useSelect);\n\n          list.append(noneElement);\n        }\n      }\n\n      if (settings.className) {\n        wrapped_list.addClass(settings.className);\n      }\n\n      if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {\n        typeof settings.step == \"function\" ? \"function\" : settings.step;\n        wrapped_list.addClass(\"ui-timepicker-with-duration\");\n        wrapped_list.addClass(\"ui-timepicker-step-\" + settings.step);\n      }\n\n      var durStart = (_settings$durationTim = settings.durationTime()) !== null && _settings$durationTim !== void 0 ? _settings$durationTim : settings.minTime();\n      var start = (_settings$minTime = settings.minTime()) !== null && _settings$minTime !== void 0 ? _settings$minTime : 0;\n      var end = (_settings$maxTime = settings.maxTime()) !== null && _settings$maxTime !== void 0 ? _settings$maxTime : start + ONE_DAY - 1;\n\n      if (end < start) {\n        // make sure the end time is greater than start time, otherwise there will be no list to show\n        end += ONE_DAY;\n      }\n\n      if (end === ONE_DAY - 1 && $.type(settings.timeFormat) === \"string\" && settings.show2400) {\n        // show a 24:00 option when using military time\n        end = ONE_DAY;\n      }\n\n      var dr = settings.disableTimeRanges;\n      var drCur = 0;\n      var drLen = dr.length;\n      var stepFunc = settings.step;\n\n      if (typeof stepFunc != \"function\") {\n        stepFunc = function stepFunc() {\n          return settings.step;\n        };\n      }\n\n      for (var i = start, j = 0; i <= end; j++, i += stepFunc(j) * 60) {\n        var timeInt = i;\n\n        var timeString = tp._int2time(timeInt);\n\n        if (settings.useSelect) {\n          var row = $(\"<option></option>\", {\n            value: timeString\n          });\n          row.text(timeString);\n        } else {\n          var row = $(\"<li></li>\");\n          row.addClass(timeInt % ONE_DAY < ONE_DAY / 2 ? \"ui-timepicker-am\" : \"ui-timepicker-pm\");\n          row.attr(\"data-time\", roundingFunction(timeInt, settings));\n          row.text(timeString);\n        }\n\n        if ((settings.minTime() !== null || settings.durationTime() !== null) && settings.showDuration) {\n          var durationString = tp._int2duration(i - durStart, settings.step);\n\n          if (settings.useSelect) {\n            row.text(row.text() + \" (\" + durationString + \")\");\n          } else {\n            var duration = $(\"<span></span>\", {\n              \"class\": \"ui-timepicker-duration\"\n            });\n            duration.text(\" (\" + durationString + \")\");\n            row.append(duration);\n          }\n        }\n\n        if (drCur < drLen) {\n          if (timeInt >= dr[drCur][1]) {\n            drCur += 1;\n          }\n\n          if (dr[drCur] && timeInt >= dr[drCur][0] && timeInt < dr[drCur][1]) {\n            if (settings.useSelect) {\n              row.prop(\"disabled\", true);\n            } else {\n              row.addClass(\"ui-timepicker-disabled\");\n            }\n          }\n        }\n\n        list.append(row);\n      }\n\n      wrapped_list.data(\"timepicker-input\", self);\n      tp.list = wrapped_list;\n\n      if (settings.useSelect) {\n        if (self.val()) {\n          list.val(tp._roundAndFormatTime(tp.anytime2int(self.val())));\n        }\n\n        list.on(\"focus\", function () {\n          $(this).data(\"timepicker-input\").trigger(\"showTimepicker\");\n        });\n        list.on(\"blur\", function () {\n          $(this).data(\"timepicker-input\").trigger(\"hideTimepicker\");\n        });\n        list.on(\"change\", function () {\n          tp._setTimeValue($(this).val(), \"select\");\n        });\n\n        tp._setTimeValue(list.val(), \"initial\");\n\n        self.hide().after(list);\n      } else {\n        var appendTo = settings.appendTo;\n\n        if (typeof appendTo === \"string\") {\n          appendTo = $(appendTo);\n        } else if (typeof appendTo === \"function\") {\n          appendTo = appendTo(self);\n        }\n\n        appendTo.append(wrapped_list);\n\n        tp._setSelected();\n\n        list.on(\"mousedown click\", \"li\", function (e) {\n          // hack: temporarily disable the focus handler\n          // to deal with the fact that IE fires 'focus'\n          // events asynchronously\n          self.off(\"focus.timepicker\");\n          self.on(\"focus.timepicker-ie-hack\", function () {\n            self.off(\"focus.timepicker-ie-hack\");\n            self.on(\"focus.timepicker\", methods.show);\n          });\n\n          if (!tp._hideKeyboard()) {\n            self[0].focus();\n          } // make sure only the clicked row is selected\n\n\n          list.find(\"li\").removeClass(\"ui-timepicker-selected\");\n          $(this).addClass(\"ui-timepicker-selected\");\n\n          if (tp._selectValue()) {\n            self.trigger(\"hideTimepicker\");\n            list.on(\"mouseup.timepicker click.timepicker\", \"li\", function (e) {\n              list.off(\"mouseup.timepicker click.timepicker\");\n              wrapped_list.hide();\n            });\n          }\n        });\n      }\n    } // event handler to decide whether to close timepicker\n\n\n    function _closeHandler(e) {\n      if (e.type == 'focus' && e.target == window) {\n        // mobile Chrome fires focus events against window for some reason\n        return;\n      }\n\n      var target = $(e.target);\n\n      if (target.closest(\".ui-timepicker-input\").length || target.closest(\".ui-timepicker-wrapper\").length) {\n        // active timepicker was focused. ignore\n        return;\n      }\n\n      Timepicker.hideAll();\n      $(document).unbind(\".ui-timepicker\");\n      $(window).unbind(\".ui-timepicker\");\n    }\n    /*\n     *  Keyboard navigation via arrow keys\n     */\n\n\n    function _keydownhandler(e) {\n      var self = $(this);\n      var tp = self[0].timepickerObj;\n      var list = tp.list;\n\n      if (!list || !Timepicker.isVisible(list)) {\n        if (e.keyCode == 40) {\n          // show the list!\n          methods.show.call(self.get(0));\n          list = tp.list;\n\n          if (!tp._hideKeyboard()) {\n            self.trigger('focus');\n          }\n        } else {\n          return true;\n        }\n      }\n\n      switch (e.keyCode) {\n        case 13:\n          // return\n          if (tp._selectValue()) {\n            tp._formatValue({\n              type: \"change\"\n            });\n\n            tp.hideMe();\n          }\n\n          e.preventDefault();\n          return false;\n\n        case 38:\n          // up\n          var selected = list.find(\".ui-timepicker-selected\");\n\n          if (!selected.length) {\n            list.find(\"li\").each(function (i, obj) {\n              if ($(obj).position().top > 0) {\n                selected = $(obj);\n                return false;\n              }\n            });\n            selected.addClass(\"ui-timepicker-selected\");\n          } else if (!selected.is(\":first-child\")) {\n            selected.removeClass(\"ui-timepicker-selected\");\n            selected.prev().addClass(\"ui-timepicker-selected\");\n\n            if (selected.prev().position().top < selected.outerHeight()) {\n              list.scrollTop(list.scrollTop() - selected.outerHeight());\n            }\n          }\n\n          return false;\n\n        case 40:\n          // down\n          selected = list.find(\".ui-timepicker-selected\");\n\n          if (selected.length === 0) {\n            list.find(\"li\").each(function (i, obj) {\n              if ($(obj).position().top > 0) {\n                selected = $(obj);\n                return false;\n              }\n            });\n            selected.addClass(\"ui-timepicker-selected\");\n          } else if (!selected.is(\":last-child\")) {\n            selected.removeClass(\"ui-timepicker-selected\");\n            selected.next().addClass(\"ui-timepicker-selected\");\n\n            if (selected.next().position().top + 2 * selected.outerHeight() > list.outerHeight()) {\n              list.scrollTop(list.scrollTop() + selected.outerHeight());\n            }\n          }\n\n          return false;\n\n        case 27:\n          // escape\n          list.find(\"li\").removeClass(\"ui-timepicker-selected\");\n          tp.hideMe();\n          break;\n\n        case 9:\n          //tab\n          tp.hideMe();\n          break;\n\n        default:\n          return true;\n      }\n    } // Plugin entry\n\n\n    $.fn.timepicker = function (method) {\n      if (!this.length) return this;\n\n      if (methods[method]) {\n        // check if this element is a timepicker\n        if (!this.hasClass(\"ui-timepicker-input\")) {\n          return this;\n        }\n\n        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n      } else if (_typeof(method) === \"object\" || !method) {\n        return methods.init.apply(this, arguments);\n      } else {\n        $.error(\"Method \" + method + \" does not exist on jQuery.timepicker\");\n      }\n    }; // Default plugin options.\n\n\n    $.fn.timepicker.defaults = DEFAULT_SETTINGS;\n  });\n\n}());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXBpY2tlci9qcXVlcnkudGltZXBpY2tlci5qcz8yMDUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtEQUFrRDs7QUFFbEQsNEhBQTRIOztBQUU1SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3REFBd0QsZ0NBQWdDO0FBQ3hGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBLFdBQVcsRUFBRTs7QUFFYiw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLHFDQUFxQztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGlDQUFpQztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRyxHQUFHOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsU0FBUyxNQUE4QixHQUFHLFNBQVcsaURBQWlELE1BQTZCLEdBQUcsU0FBVztBQUNqSjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxzQkFBUTtBQUM5QixLQUFLLFVBQVUsSUFBMEM7QUFDekQ7QUFDQSxNQUFNLGlDQUFPLENBQUMsMkNBQVEsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQ2pDLEtBQUssTUFBTSxFQUdOO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7O0FBRzFCOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7OztBQUdUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsVUFBVTtBQUMxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7O0FBRUgsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aW1lcGlja2VyL2pxdWVyeS50aW1lcGlja2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqcXVlcnktdGltZXBpY2tlciB2MS4xMy4xOCAtIEEgalF1ZXJ5IHRpbWVwaWNrZXIgcGx1Z2luIGluc3BpcmVkIGJ5IEdvb2dsZSBDYWxlbmRhci4gSXQgc3VwcG9ydHMgYm90aCBtb3VzZSBhbmQga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAqIENvcHlyaWdodCAoYykgMjAyMSBKb24gVGhvcm50b24gLSBodHRwczovL3d3dy5qb250aG9ybnRvbi5jb20vanF1ZXJ5LXRpbWVwaWNrZXIvXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgICB2YXIgaXQ7XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzOiBGLFxuICAgICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGY6IEZcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICAgIGVycjtcbiAgICByZXR1cm4ge1xuICAgICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgfSxcbiAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7XG4gICAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfSxcbiAgICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9LFxuICAgICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGRpZEVycikgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBPTkVfREFZID0gODY0MDA7XG5cbiAgdmFyIHJvdW5kaW5nRnVuY3Rpb24gPSBmdW5jdGlvbiByb3VuZGluZ0Z1bmN0aW9uKHNlY29uZHMsIHNldHRpbmdzKSB7XG4gICAgaWYgKHNlY29uZHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzLnN0ZXAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIC8vIFRPRE86IG5lYXJlc3QgZml0IGlycmVndWxhciBzdGVwc1xuICAgICAgcmV0dXJuIHNlY29uZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc2V0dGluZ3MkbWluVGltZTtcblxuICAgICAgdmFyIG9mZnNldCA9IHNlY29uZHMgJSAoc2V0dGluZ3Muc3RlcCAqIDYwKTsgLy8gc3RlcCBpcyBpbiBtaW51dGVzXG5cbiAgICAgIHZhciBzdGFydCA9IChfc2V0dGluZ3MkbWluVGltZSA9IHNldHRpbmdzLm1pblRpbWUoKSkgIT09IG51bGwgJiYgX3NldHRpbmdzJG1pblRpbWUgIT09IHZvaWQgMCA/IF9zZXR0aW5ncyRtaW5UaW1lIDogMDsgLy8gYWRqdXN0IG9mZnNldCBieSBzdGFydCBtb2Qgc3RlcCBzbyB0aGF0IHRoZSBvZmZzZXQgaXMgYWxpZ25lZCBub3QgdG8gMDA6MDAgYnV0IHRvIHRoZSBzdGFydFxuXG4gICAgICBvZmZzZXQgLT0gc3RhcnQgJSAoc2V0dGluZ3Muc3RlcCAqIDYwKTtcblxuICAgICAgaWYgKG9mZnNldCA+PSBzZXR0aW5ncy5zdGVwICogMzApIHtcbiAgICAgICAgLy8gaWYgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIGEgaGFsZiBzdGVwLCByb3VuZCB1cFxuICAgICAgICBzZWNvbmRzICs9IHNldHRpbmdzLnN0ZXAgKiA2MCAtIG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJvdW5kIGRvd25cbiAgICAgICAgc2Vjb25kcyAtPSBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbW9kdWxvU2Vjb25kcyhzZWNvbmRzLCBzZXR0aW5ncyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9tb2R1bG9TZWNvbmRzKHNlY29uZHMsIHNldHRpbmdzKSB7XG4gICAgaWYgKHNlY29uZHMgPT0gT05FX0RBWSAmJiBzZXR0aW5ncy5zaG93MjQwMCkge1xuICAgICAgcmV0dXJuIHNlY29uZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY29uZHMgJSBPTkVfREFZO1xuICB9XG5cbiAgdmFyIERFRkFVTFRfU0VUVElOR1MgPSB7XG4gICAgYXBwZW5kVG86IFwiYm9keVwiLFxuICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICBjbG9zZU9uV2luZG93U2Nyb2xsOiBmYWxzZSxcbiAgICBkaXNhYmxlVGV4dElucHV0OiBmYWxzZSxcbiAgICBkaXNhYmxlVGltZVJhbmdlczogW10sXG4gICAgZGlzYWJsZVRvdWNoS2V5Ym9hcmQ6IGZhbHNlLFxuICAgIGR1cmF0aW9uVGltZTogbnVsbCxcbiAgICBmb3JjZVJvdW5kVGltZTogZmFsc2UsXG4gICAgbGFuZzoge30sXG4gICAgbGlzdFdpZHRoOiBudWxsLFxuICAgIG1heFRpbWU6IG51bGwsXG4gICAgbWluVGltZTogbnVsbCxcbiAgICBub25lT3B0aW9uOiBmYWxzZSxcbiAgICBvcmllbnRhdGlvbjogXCJsXCIsXG4gICAgcm91bmRpbmdGdW5jdGlvbjogcm91bmRpbmdGdW5jdGlvbixcbiAgICBzY3JvbGxEZWZhdWx0OiBudWxsLFxuICAgIHNlbGVjdE9uQmx1cjogZmFsc2UsXG4gICAgc2hvdzI0MDA6IGZhbHNlLFxuICAgIHNob3dEdXJhdGlvbjogZmFsc2UsXG4gICAgc2hvd09uOiBbXCJjbGlja1wiLCBcImZvY3VzXCJdLFxuICAgIHNob3dPbkZvY3VzOiB0cnVlLFxuICAgIHN0ZXA6IDMwLFxuICAgIHN0b3BTY3JvbGxQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgdGltZUZvcm1hdDogXCJnOmlhXCIsXG4gICAgdHlwZWFoZWFkSGlnaGxpZ2h0OiB0cnVlLFxuICAgIHVzZVNlbGVjdDogZmFsc2UsXG4gICAgd3JhcEhvdXJzOiB0cnVlXG4gIH07XG4gIHZhciBERUZBVUxUX0xBTkcgPSB7XG4gICAgYW06IFwiYW1cIixcbiAgICBwbTogXCJwbVwiLFxuICAgIEFNOiBcIkFNXCIsXG4gICAgUE06IFwiUE1cIixcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICBtaW5zOiBcIm1pbnNcIixcbiAgICBocjogXCJoclwiLFxuICAgIGhyczogXCJocnNcIlxuICB9O1xuXG4gIHZhciBFVkVOVF9ERUZBVUxUUyA9IHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgIGRldGFpbDogbnVsbFxuICB9O1xuXG4gIHZhciBUaW1lcGlja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lcGlja2VyKHRhcmdldEVsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lcGlja2VyKTtcblxuICAgICAgdGhpcy5faGFuZGxlRm9ybWF0VmFsdWUgPSB0aGlzLl9oYW5kbGVGb3JtYXRWYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5faGFuZGxlS2V5VXAgPSB0aGlzLl9oYW5kbGVLZXlVcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy50YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgdmFyIGF0dHJPcHRpb25zID0gVGltZXBpY2tlci5leHRyYWN0QXR0ck9wdGlvbnModGFyZ2V0RWwsIE9iamVjdC5rZXlzKERFRkFVTFRfU0VUVElOR1MpKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLnBhcnNlU2V0dGluZ3MoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfU0VUVElOR1MpLCBvcHRpb25zKSwgYXR0ck9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZXBpY2tlciwgW3tcbiAgICAgIGtleTogXCJoaWRlTWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlTWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnVzZVNlbGVjdCkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0RWwuYmx1cigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5saXN0IHx8ICFUaW1lcGlja2VyLmlzVmlzaWJsZSh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VsZWN0T25CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlzdC5oaWRlKCk7XG4gICAgICAgIHZhciBoaWRlVGltZXBpY2tlckV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdoaWRlVGltZXBpY2tlcicsIEVWRU5UX0RFRkFVTFRTKTtcbiAgICAgICAgdGhpcy50YXJnZXRFbC5kaXNwYXRjaEV2ZW50KGhpZGVUaW1lcGlja2VyRXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZmluZFJvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kUm93KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0ID0gZmFsc2U7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2V0dGluZ3Mucm91bmRpbmdGdW5jdGlvbih2YWx1ZSwgdGhpcy5zZXR0aW5ncyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3QuZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24gKGksIG9iaikge1xuICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChvYmouZGF0YXNldC50aW1lKTtcblxuICAgICAgICAgIGlmIChpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcnNlZCA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgb3V0ID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oaWRlS2V5Ym9hcmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZUtleWJvYXJkKCkge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyB8fCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50KSAmJiB0aGlzLnNldHRpbmdzLmRpc2FibGVUb3VjaEtleWJvYXJkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0VGltZVZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFRpbWVWYWx1ZSh2YWx1ZSwgc291cmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldEVsLm5vZGVOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgfHwgdGhpcy50YXJnZXRFbC52YWx1ZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRwID0gdGhpcztcbiAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB0cC5zZXR0aW5ncztcblxuICAgICAgICAgIGlmIChzZXR0aW5ncy51c2VTZWxlY3QgJiYgc291cmNlICE9IFwic2VsZWN0XCIgJiYgdHAubGlzdCkge1xuICAgICAgICAgICAgdHAubGlzdC52YWwodHAuX3JvdW5kQW5kRm9ybWF0VGltZSh0cC5hbnl0aW1lMmludCh2YWx1ZSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0VGltZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZWxlY3RUaW1lJywgRVZFTlRfREVGQVVMVFMpO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkVmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB2YXIgY2hhbmdlVGltZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2VUaW1lJywgRVZFTlRfREVGQVVMVFMpO1xuICAgICAgICAgIHZhciBjaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywgT2JqZWN0LmFzc2lnbihFVkVOVF9ERUZBVUxUUywge1xuICAgICAgICAgICAgZGV0YWlsOiAndGltZXBpY2tlcidcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBpZiAoc291cmNlID09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWwuZGlzcGF0Y2hFdmVudChzZWxlY3RUaW1lRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbC5kaXNwYXRjaEV2ZW50KGNoYW5nZVRpbWVFdmVudCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsLmRpc3BhdGNoRXZlbnQoY2hhbmdlRXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoW1wiZXJyb3JcIiwgXCJpbml0aWFsXCJdLmluZGV4T2Yoc291cmNlKSA9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbC5kaXNwYXRjaEV2ZW50KGNoYW5nZVRpbWVFdmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFtcImVycm9yXCIsIFwiaW5pdGlhbFwiXS5pbmRleE9mKHNvdXJjZSkgPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWwuZGlzcGF0Y2hFdmVudChzZWxlY3RUaW1lRXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0VGltZVZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRpbWVWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0RWwubm9kZU5hbWUgPT09IFwiSU5QVVRcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldEVsLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSB0aGUgZWxlbWVudCdzIGRhdGEgYXR0cmlidXRlcyB0byBzdG9yZSB2YWx1ZXNcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZWxlY3RWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZWxlY3RWYWx1ZSgpIHtcbiAgICAgICAgdmFyIHRwID0gdGhpcztcbiAgICAgICAgdHAuc2V0dGluZ3M7XG4gICAgICAgIHZhciBsaXN0ID0gdHAubGlzdDtcbiAgICAgICAgdmFyIGN1cnNvciA9IGxpc3QuZmluZChcIi51aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuXG4gICAgICAgIGlmIChjdXJzb3IuaGFzQ2xhc3MoXCJ1aS10aW1lcGlja2VyLWRpc2FibGVkXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjdXJzb3IubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGltZVZhbHVlID0gY3Vyc29yLmdldCgwKS5kYXRhc2V0LnRpbWU7IC8vIHNlbGVjdGVkIHZhbHVlIGZvdW5kXG5cbiAgICAgICAgaWYgKHRpbWVWYWx1ZSkge1xuICAgICAgICAgIHZhciBwYXJzZWRUaW1lVmFsdWUgPSBwYXJzZUludCh0aW1lVmFsdWUpO1xuXG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZWRUaW1lVmFsdWUpKSB7XG4gICAgICAgICAgICB0aW1lVmFsdWUgPSBwYXJzZWRUaW1lVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWVWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGltZVZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRpbWVWYWx1ZSA9IHRwLl9pbnQydGltZSh0aW1lVmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRwLl9zZXRUaW1lVmFsdWUodGltZVZhbHVlLCBcInNlbGVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbnl0aW1lMmludFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFueXRpbWUyaW50KGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50aW1lMmludChpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnICYmIGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiBpbnB1dC5nZXRIb3VycygpICogMzYwMCArIGlucHV0LmdldE1pbnV0ZXMoKSAqIDYwICsgaW5wdXQuZ2V0U2Vjb25kcygpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGltZTJpbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lMmludCh0aW1lU3RyaW5nKSB7XG4gICAgICAgIGlmICh0aW1lU3RyaW5nID09PSBcIlwiIHx8IHRpbWVTdHJpbmcgPT09IG51bGwgfHwgdGltZVN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGltZVN0cmluZyA9PT0gJ25vdycpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbnl0aW1lMmludChuZXcgRGF0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGltZVN0cmluZyAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHRpbWVTdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lU3RyaW5nID0gdGltZVN0cmluZy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1tcXHNcXC5dL2csIFwiXCIpOyAvLyBpZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYW4gXCJhXCIgb3IgXCJwXCIsIGFkZCB0aGUgXCJtXCJcblxuICAgICAgICBpZiAodGltZVN0cmluZy5zbGljZSgtMSkgPT0gXCJhXCIgfHwgdGltZVN0cmluZy5zbGljZSgtMSkgPT0gXCJwXCIpIHtcbiAgICAgICAgICB0aW1lU3RyaW5nICs9IFwibVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdHRlcm4gPSAvXigoW14wLTldKikpPyhbMC05XT9bMC05XSkoKFswLTVdWzAtOV0pKT8oKFswLTVdWzAtOV0pKT8oKFteMC05XSopKSQvO1xuICAgICAgICB2YXIgaGFzRGVsaW1ldGVyc01hdGNoID0gdGltZVN0cmluZy5tYXRjaCgvXFxXLyk7XG5cbiAgICAgICAgaWYgKGhhc0RlbGltZXRlcnNNYXRjaCkge1xuICAgICAgICAgIHBhdHRlcm4gPSAvXigoW14wLTldKikpPyhbMC05XT9bMC05XSkoXFxXKyhbMC01XVswLTldPykpPyhcXFcrKFswLTVdWzAtOV0pKT8oKFteMC05XSopKSQvO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpbWUgPSB0aW1lU3RyaW5nLm1hdGNoKHBhdHRlcm4pO1xuXG4gICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhvdXIgPSBwYXJzZUludCh0aW1lWzNdICogMSwgMTApO1xuICAgICAgICB2YXIgYW1wbSA9IHRpbWVbMl0gfHwgdGltZVs5XTtcbiAgICAgICAgdmFyIGhvdXJzID0gaG91cjtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSB0aW1lWzVdICogMSB8fCAwO1xuICAgICAgICB2YXIgc2Vjb25kcyA9IHRpbWVbN10gKiAxIHx8IDA7XG5cbiAgICAgICAgaWYgKCFhbXBtICYmIHRpbWVbM10ubGVuZ3RoID09IDIgJiYgdGltZVszXVswXSA9PSBcIjBcIikge1xuICAgICAgICAgIC8vIHByZWNlZGluZyAnMCcgaW1wbGllcyBBTVxuICAgICAgICAgIGFtcG0gPSBcImFtXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG91ciA8PSAxMiAmJiBhbXBtKSB7XG4gICAgICAgICAgYW1wbSA9IGFtcG0udHJpbSgpO1xuICAgICAgICAgIHZhciBpc1BtID0gYW1wbSA9PSB0aGlzLnNldHRpbmdzLmxhbmcucG0gfHwgYW1wbSA9PSB0aGlzLnNldHRpbmdzLmxhbmcuUE07XG5cbiAgICAgICAgICBpZiAoaG91ciA9PSAxMikge1xuICAgICAgICAgICAgaG91cnMgPSBpc1BtID8gMTIgOiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob3VycyA9IGhvdXIgKyAoaXNQbSA/IDEyIDogMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0ID0gaG91ciAqIDM2MDAgKyBtaW51dGVzICogNjAgKyBzZWNvbmRzO1xuXG4gICAgICAgICAgaWYgKHQgPj0gT05FX0RBWSArICh0aGlzLnNldHRpbmdzLnNob3cyNDAwID8gMSA6IDApKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy53cmFwSG91cnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob3VycyA9IGhvdXIgJSAyNDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGltZUludCA9IGhvdXJzICogMzYwMCArIG1pbnV0ZXMgKiA2MCArIHNlY29uZHM7IC8vIGlmIG5vIGFtL3BtIHByb3ZpZGVkLCBpbnRlbGxpZ2VudGx5IGd1ZXNzIGJhc2VkIG9uIHRoZSBzY3JvbGxEZWZhdWx0XG5cbiAgICAgICAgaWYgKGhvdXIgPCAxMiAmJiAhYW1wbSAmJiB0aGlzLnNldHRpbmdzLl90d2VsdmVIb3VyVGltZSAmJiB0aGlzLnNldHRpbmdzLnNjcm9sbERlZmF1bHQoKSkge1xuICAgICAgICAgIHZhciBkZWx0YSA9IHRpbWVJbnQgLSB0aGlzLnNldHRpbmdzLnNjcm9sbERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChkZWx0YSA8IDAgJiYgZGVsdGEgPj0gT05FX0RBWSAvIC0yKSB7XG4gICAgICAgICAgICB0aW1lSW50ID0gKHRpbWVJbnQgKyBPTkVfREFZIC8gMikgJSBPTkVfREFZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW1lSW50O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbnRTdHJpbmdEYXRlT3JGdW5jMmZ1bmNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRTdHJpbmdEYXRlT3JGdW5jMmZ1bmMoaW5wdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYW55dGltZTJpbnQoaW5wdXQoKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFueXRpbWUyaW50KGlucHV0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhcnNlU2V0dGluZ3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzLmxhbmcgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9MQU5HKSwgc2V0dGluZ3MubGFuZyk7IC8vIGxhbmcgaXMgdXNlZCBieSBvdGhlciBmdW5jdGlvbnMgdGhlIHJlc3Qgb2YgdGhpcyBkZXBlbmRzIG9uXG4gICAgICAgIC8vIHRvZG86IHVud2luZCBjaXJjdWxhciBkZXBlbmRlbmN5IG9uIGxhbmdcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxpc3RXaWR0aCkge1xuICAgICAgICAgIHNldHRpbmdzLmxpc3RXaWR0aCA9IHRoaXMuYW55dGltZTJpbnQoc2V0dGluZ3MubGlzdFdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLm1pblRpbWUgPSB0aGlzLmludFN0cmluZ0RhdGVPckZ1bmMyZnVuYyhzZXR0aW5ncy5taW5UaW1lKTtcbiAgICAgICAgc2V0dGluZ3MubWF4VGltZSA9IHRoaXMuaW50U3RyaW5nRGF0ZU9yRnVuYzJmdW5jKHNldHRpbmdzLm1heFRpbWUpO1xuICAgICAgICBzZXR0aW5ncy5kdXJhdGlvblRpbWUgPSB0aGlzLmludFN0cmluZ0RhdGVPckZ1bmMyZnVuYyhzZXR0aW5ncy5kdXJhdGlvblRpbWUpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5zY3JvbGxEZWZhdWx0KSB7XG4gICAgICAgICAgc2V0dGluZ3Muc2Nyb2xsRGVmYXVsdCA9IHRoaXMuaW50U3RyaW5nRGF0ZU9yRnVuYzJmdW5jKHNldHRpbmdzLnNjcm9sbERlZmF1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldHRpbmdzLnNjcm9sbERlZmF1bHQgPSBzZXR0aW5ncy5taW5UaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy50aW1lRm9ybWF0ID09PSBcInN0cmluZ1wiICYmIHNldHRpbmdzLnRpbWVGb3JtYXQubWF0Y2goL1tnaF0vKSkge1xuICAgICAgICAgIHNldHRpbmdzLl90d2VsdmVIb3VyVGltZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3Muc2hvd09uRm9jdXMgPT09IGZhbHNlICYmIHNldHRpbmdzLnNob3dPbi5pbmRleE9mKFwiZm9jdXNcIikgIT0gLTEpIHtcbiAgICAgICAgICBzZXR0aW5ncy5zaG93T24uc3BsaWNlKHNldHRpbmdzLnNob3dPbi5pbmRleE9mKFwiZm9jdXNcIiksIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcykge1xuICAgICAgICAgIHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRpbWVzIHRvIGludGVnZXJzXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcykge1xuICAgICAgICAgICAgc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV0gPSBbdGhpcy5hbnl0aW1lMmludChzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVswXSksIHRoaXMuYW55dGltZTJpbnQoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV1bMV0pXTtcbiAgICAgICAgICB9IC8vIHNvcnQgYnkgc3RhcnRpbmcgdGltZVxuXG5cbiAgICAgICAgICBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcyA9IHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICAgICAgICB9KTsgLy8gbWVyZ2UgYW55IG92ZXJsYXBwaW5nIHJhbmdlc1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVswXSA8PSBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpIC0gMV1bMV0pIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaSAtIDFdID0gW01hdGgubWluKHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldWzBdLCBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpIC0gMV1bMF0pLCBNYXRoLm1heChzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVsxXSwgc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaSAtIDFdWzFdKV07XG4gICAgICAgICAgICAgIHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogIEZpbHRlciBmcmVlZm9ybSBpbnB1dFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2Rpc2FibGVUZXh0SW5wdXRIYW5kbGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc2FibGVUZXh0SW5wdXRIYW5kbGVyKGUpIHtcbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIDEzOiAvLyByZXR1cm5cblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIC8vdGFiXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pbnQyZHVyYXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW50MmR1cmF0aW9uKHNlY29uZHMsIHN0ZXApIHtcbiAgICAgICAgc2Vjb25kcyA9IE1hdGguYWJzKHNlY29uZHMpO1xuICAgICAgICB2YXIgbWludXRlcyA9IE1hdGgucm91bmQoc2Vjb25kcyAvIDYwKSxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gW10sXG4gICAgICAgICAgICBob3VycyxcbiAgICAgICAgICAgIG1pbnM7XG5cbiAgICAgICAgaWYgKG1pbnV0ZXMgPCA2MCkge1xuICAgICAgICAgIC8vIE9ubHkgc2hvdyAoeCBtaW5zKSB1bmRlciAxIGhvdXJcbiAgICAgICAgICBkdXJhdGlvbiA9IFttaW51dGVzLCB0aGlzLnNldHRpbmdzLmxhbmcubWluc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgICAgbWlucyA9IG1pbnV0ZXMgJSA2MDsgLy8gU2hvdyBkZWNpbWFsIG5vdGF0aW9uIChlZzogMS41IGhycykgZm9yIDMwIG1pbnV0ZSBzdGVwc1xuXG4gICAgICAgICAgaWYgKHN0ZXAgPT0gMzAgJiYgbWlucyA9PSAzMCkge1xuICAgICAgICAgICAgaG91cnMgKz0gdGhpcy5zZXR0aW5ncy5sYW5nLmRlY2ltYWwgKyA1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGR1cmF0aW9uLnB1c2goaG91cnMpO1xuICAgICAgICAgIGR1cmF0aW9uLnB1c2goaG91cnMgPT0gMSA/IHRoaXMuc2V0dGluZ3MubGFuZy5ociA6IHRoaXMuc2V0dGluZ3MubGFuZy5ocnMpOyAvLyBTaG93IHJlbWFpbmRlciBtaW51dGVzIG5vdGF0aW9uIChlZzogMSBociAxNSBtaW5zKSBmb3Igbm9uLTMwIG1pbnV0ZSBzdGVwc1xuICAgICAgICAgIC8vIGFuZCBvbmx5IGlmIHRoZXJlIGFyZSByZW1haW5kZXIgbWludXRlcyB0byBzaG93XG5cbiAgICAgICAgICBpZiAoc3RlcCAhPSAzMCAmJiBtaW5zKSB7XG4gICAgICAgICAgICBkdXJhdGlvbi5wdXNoKG1pbnMpO1xuICAgICAgICAgICAgZHVyYXRpb24ucHVzaCh0aGlzLnNldHRpbmdzLmxhbmcubWlucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLmpvaW4oXCIgXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfcm91bmRBbmRGb3JtYXRUaW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JvdW5kQW5kRm9ybWF0VGltZShzZWNvbmRzKSB7XG4gICAgICAgIHNlY29uZHMgPSB0aGlzLnNldHRpbmdzLnJvdW5kaW5nRnVuY3Rpb24oc2Vjb25kcywgdGhpcy5zZXR0aW5ncyk7XG5cbiAgICAgICAgaWYgKHNlY29uZHMgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW50MnRpbWUoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2ludDJ0aW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ludDJ0aW1lKHRpbWVJbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lSW50ICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gcGFyc2VJbnQodGltZUludCAlIDYwKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lSW50IC8gNjAgJSA2MCksXG4gICAgICAgICAgICBob3VycyA9IHBhcnNlSW50KHRpbWVJbnQgLyAoNjAgKiA2MCkgJSAyNCk7XG4gICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoMTk3MCwgMCwgMiwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIDApO1xuXG4gICAgICAgIGlmIChpc05hTih0aW1lLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXR0aW5ncy50aW1lRm9ybWF0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50aW1lRm9ybWF0KHRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgIHZhciBob3VyLCBjb2RlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXR0aW5ncy50aW1lRm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29kZSA9IHRoaXMuc2V0dGluZ3MudGltZUZvcm1hdC5jaGFyQXQoaSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICAgIG91dHB1dCArPSB0aW1lLmdldEhvdXJzKCkgPiAxMSA/IHRoaXMuc2V0dGluZ3MubGFuZy5wbSA6IHRoaXMuc2V0dGluZ3MubGFuZy5hbTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgIG91dHB1dCArPSB0aW1lLmdldEhvdXJzKCkgPiAxMSA/IHRoaXMuc2V0dGluZ3MubGFuZy5QTSA6IHRoaXMuc2V0dGluZ3MubGFuZy5BTTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgICAgICAgIGhvdXIgPSB0aW1lLmdldEhvdXJzKCkgJSAxMjtcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IGhvdXIgPT09IDAgPyBcIjEyXCIgOiBob3VyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgICAgaG91ciA9IHRpbWUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgaWYgKHRpbWVJbnQgPT09IE9ORV9EQVkpIGhvdXIgPSB0aGlzLnNldHRpbmdzLnNob3cyNDAwID8gMjQgOiAwO1xuICAgICAgICAgICAgICBvdXRwdXQgKz0gaG91cjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICAgIGhvdXIgPSB0aW1lLmdldEhvdXJzKCkgJSAxMjtcblxuICAgICAgICAgICAgICBpZiAoaG91ciAhPT0gMCAmJiBob3VyIDwgMTApIHtcbiAgICAgICAgICAgICAgICBob3VyID0gXCIwXCIgKyBob3VyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3V0cHV0ICs9IGhvdXIgPT09IDAgPyBcIjEyXCIgOiBob3VyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgaG91ciA9IHRpbWUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgaWYgKHRpbWVJbnQgPT09IE9ORV9EQVkpIGhvdXIgPSB0aGlzLnNldHRpbmdzLnNob3cyNDAwID8gMjQgOiAwO1xuICAgICAgICAgICAgICBvdXRwdXQgKz0gaG91ciA+IDkgPyBob3VyIDogXCIwXCIgKyBob3VyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgICAgdmFyIG1pbnV0ZXMgPSB0aW1lLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IG1pbnV0ZXMgPiA5ID8gbWludXRlcyA6IFwiMFwiICsgbWludXRlcztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgIHNlY29uZHMgPSB0aW1lLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IHNlY29uZHMgPiA5ID8gc2Vjb25kcyA6IFwiMFwiICsgc2Vjb25kcztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXI7IGFkZCB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHNraXAgYWhlYWRcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBvdXRwdXQgKz0gdGhpcy5zZXR0aW5ncy50aW1lRm9ybWF0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG91dHB1dCArPSBjb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRTZWxlY3RlZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTZWxlY3RlZCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmxpc3Q7XG4gICAgICAgIGxpc3QuZmluZChcImxpXCIpLnJlbW92ZUNsYXNzKFwidWktdGltZXBpY2tlci1zZWxlY3RlZFwiKTtcbiAgICAgICAgdmFyIHRpbWVWYWx1ZSA9IHRoaXMuYW55dGltZTJpbnQodGhpcy5fZ2V0VGltZVZhbHVlKCkpO1xuXG4gICAgICAgIGlmICh0aW1lVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLl9maW5kUm93KHRpbWVWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkUmVjdCA9IHNlbGVjdGVkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHZhciBsaXN0UmVjdCA9IGxpc3QuZ2V0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHZhciB0b3BEZWx0YSA9IHNlbGVjdGVkUmVjdC50b3AgLSBsaXN0UmVjdC50b3A7XG5cbiAgICAgICAgICBpZiAodG9wRGVsdGEgKyBzZWxlY3RlZFJlY3QuaGVpZ2h0ID4gbGlzdFJlY3QuaGVpZ2h0IHx8IHRvcERlbHRhIDwgMCkge1xuICAgICAgICAgICAgdmFyIG5ld1Njcm9sbCA9IGxpc3Quc2Nyb2xsVG9wKCkgKyAoc2VsZWN0ZWRSZWN0LnRvcCAtIGxpc3RSZWN0LnRvcCkgLSBzZWxlY3RlZFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgbGlzdC5zY3JvbGxUb3AobmV3U2Nyb2xsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc2VsZWN0ZWQuZGF0YXNldC50aW1lKTtcblxuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmZvcmNlUm91bmRUaW1lIHx8IHBhcnNlZCA9PT0gdGltZVZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5jbGFzc0xpc3QuYWRkKCd1aS10aW1lcGlja2VyLXNlbGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pc0ZvY3VzZWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNGb2N1c2VkKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUZvcm1hdFZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUZvcm1hdFZhbHVlKGUpIHtcbiAgICAgICAgaWYgKGUgJiYgZS5kZXRhaWwgPT0gXCJ0aW1lcGlja2VyXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mb3JtYXRWYWx1ZShlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2Zvcm1hdFZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Zvcm1hdFZhbHVlKGUsIG9yaWdpbikge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRFbC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRoaXMuX3NldFRpbWVWYWx1ZShudWxsLCBvcmlnaW4pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIElFIGZpcmVzIGNoYW5nZSBldmVudCBiZWZvcmUgYmx1clxuXG5cbiAgICAgICAgaWYgKHRoaXMuX2lzRm9jdXNlZCh0aGlzLnRhcmdldEVsKSAmJiAoIWUgfHwgZS50eXBlICE9IFwiY2hhbmdlXCIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgICAgdmFyIHNlY29uZHMgPSB0aGlzLmFueXRpbWUyaW50KHRoaXMudGFyZ2V0RWwudmFsdWUpO1xuXG4gICAgICAgIGlmIChzZWNvbmRzID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHRpbWVGb3JtYXRFcnJvckV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd0aW1lRm9ybWF0RXJyb3InLCBFVkVOVF9ERUZBVUxUUyk7XG4gICAgICAgICAgdGhpcy50YXJnZXRFbC5kaXNwYXRjaEV2ZW50KHRpbWVGb3JtYXRFcnJvckV2ZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2VFcnJvciA9IGZhbHNlOyAvLyBjaGVjayB0aGF0IHRoZSB0aW1lIGluIHdpdGhpbiBib3VuZHNcblxuICAgICAgICBpZiAoc2V0dGluZ3MubWluVGltZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5tYXhUaW1lICE9PSBudWxsICYmIChzZWNvbmRzIDwgc2V0dGluZ3MubWluVGltZSgpIHx8IHNlY29uZHMgPiBzZXR0aW5ncy5tYXhUaW1lKCkpKSB7XG4gICAgICAgICAgcmFuZ2VFcnJvciA9IHRydWU7XG4gICAgICAgIH0gLy8gY2hlY2sgdGhhdCB0aW1lIGlzbid0IHdpdGhpbiBkaXNhYmxlZCB0aW1lIHJhbmdlc1xuXG5cbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoc2Vjb25kcyA+PSByYW5nZVswXSAmJiBzZWNvbmRzIDwgcmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgcmFuZ2VFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmZvcmNlUm91bmRUaW1lKSB7XG4gICAgICAgICAgdmFyIHJvdW5kU2Vjb25kcyA9IHNldHRpbmdzLnJvdW5kaW5nRnVuY3Rpb24oc2Vjb25kcywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgaWYgKHJvdW5kU2Vjb25kcyAhPSBzZWNvbmRzKSB7XG4gICAgICAgICAgICBzZWNvbmRzID0gcm91bmRTZWNvbmRzO1xuICAgICAgICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldHR5VGltZSA9IHRoaXMuX2ludDJ0aW1lKHNlY29uZHMpO1xuXG4gICAgICAgIGlmIChyYW5nZUVycm9yKSB7XG4gICAgICAgICAgdGhpcy5fc2V0VGltZVZhbHVlKHByZXR0eVRpbWUpO1xuXG4gICAgICAgICAgdmFyIHRpbWVSYW5nZUVycm9yRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3RpbWVSYW5nZUVycm9yJywgRVZFTlRfREVGQVVMVFMpO1xuICAgICAgICAgIHRoaXMudGFyZ2V0RWwuZGlzcGF0Y2hFdmVudCh0aW1lUmFuZ2VFcnJvckV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXRUaW1lVmFsdWUocHJldHR5VGltZSwgb3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2VuZXJhdGVOb25lRWxlbWVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZU5vbmVFbGVtZW50KG9wdGlvblZhbHVlLCB1c2VTZWxlY3QpIHtcbiAgICAgICAgdmFyIGxhYmVsLCBjbGFzc05hbWUsIHZhbHVlO1xuXG4gICAgICAgIGlmIChfdHlwZW9mKG9wdGlvblZhbHVlKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbGFiZWwgPSBvcHRpb25WYWx1ZS5sYWJlbDtcbiAgICAgICAgICBjbGFzc05hbWUgPSBvcHRpb25WYWx1ZS5jbGFzc05hbWU7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25WYWx1ZS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGxhYmVsID0gb3B0aW9uVmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQuZXJyb3IoXCJJbnZhbGlkIG5vbmVPcHRpb24gdmFsdWVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWw7XG5cbiAgICAgICAgaWYgKHVzZVNlbGVjdCkge1xuICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgICAgIGVsLmRhdGFzZXQudGltZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5pbm5lclRleHQgPSBsYWJlbDtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogIFRpbWUgdHlwZWFoZWFkXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGFuZGxlS2V5VXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5VXAoZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMubGlzdCB8fCAhVGltZXBpY2tlci5pc1Zpc2libGUodGhpcy5saXN0KSB8fCB0aGlzLnNldHRpbmdzLmRpc2FibGVUZXh0SW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwicGFzdGVcIiB8fCBlLnR5cGUgPT09IFwiY3V0XCIpIHtcbiAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLnNldHRpbmdzLnR5cGVhaGVhZEhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICBfdGhpczIuX3NldFNlbGVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczIubGlzdC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIDk2OiAvLyBudW1wYWQgbnVtZXJhbHNcblxuICAgICAgICAgIGNhc2UgOTc6XG4gICAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICBjYXNlIDk5OlxuICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgIGNhc2UgMTAxOlxuICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgIGNhc2UgMTAzOlxuICAgICAgICAgIGNhc2UgMTA0OlxuICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgIGNhc2UgNDg6IC8vIG51bWVyYWxzXG5cbiAgICAgICAgICBjYXNlIDQ5OlxuICAgICAgICAgIGNhc2UgNTA6XG4gICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICBjYXNlIDUyOlxuICAgICAgICAgIGNhc2UgNTM6XG4gICAgICAgICAgY2FzZSA1NDpcbiAgICAgICAgICBjYXNlIDU1OlxuICAgICAgICAgIGNhc2UgNTY6XG4gICAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICBjYXNlIDY1OiAvLyBhXG5cbiAgICAgICAgICBjYXNlIDc3OiAvLyBtXG5cbiAgICAgICAgICBjYXNlIDgwOiAvLyBwXG5cbiAgICAgICAgICBjYXNlIDE4NjogLy8gY29sb25cblxuICAgICAgICAgIGNhc2UgODogLy8gYmFja3NwYWNlXG5cbiAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgLy8gZGVsZXRlXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50eXBlYWhlYWRIaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubGlzdC5oaWRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiZXh0cmFjdEF0dHJPcHRpb25zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEF0dHJPcHRpb25zKGVsZW1lbnQsIGtleXMpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoa2V5cyksXG4gICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGtleSBpbiBlbGVtZW50LmRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBlbGVtZW50LmRhdGFzZXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNWaXNpYmxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNWaXNpYmxlKGVsZW0pIHtcbiAgICAgICAgdmFyIGVsID0gZWxlbVswXTtcbiAgICAgICAgcmV0dXJuIGVsLm9mZnNldFdpZHRoID4gMCAmJiBlbC5vZmZzZXRIZWlnaHQgPiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoaWRlQWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUFsbCgpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd1aS10aW1lcGlja2VyLWlucHV0JykpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBlbCA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgIHZhciB0cCA9IGVsLnRpbWVwaWNrZXJPYmo7XG5cbiAgICAgICAgICAgIGlmICh0cCkge1xuICAgICAgICAgICAgICB0cC5oaWRlTWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVwaWNrZXI7XG4gIH0oKTsgLy8gSUU5LTExIHBvbHlmaWxsIGZvciBDdXN0b21FdmVudFxuXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihFVkVOVF9ERUZBVUxUUywgcGFyYW1zKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cblxuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICgodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihleHBvcnRzKSkgPT09IFwib2JqZWN0XCIgJiYgZXhwb3J0cyAmJiAodHlwZW9mIG1vZHVsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG1vZHVsZSkpID09PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PT0gZXhwb3J0cykge1xuICAgICAgLy8gQnJvd3NlcmlmeS4gQXR0YWNoIHRvIGpRdWVyeSBtb2R1bGUuXG4gICAgICBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgIGRlZmluZShbXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgIGZhY3RvcnkoalF1ZXJ5KTtcbiAgICB9XG4gIH0pKGZ1bmN0aW9uICgkKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSAkKHRoaXMpO1xuICAgICAgICAgIHZhciB0cCA9IG5ldyBUaW1lcGlja2VyKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHRwLnNldHRpbmdzO1xuICAgICAgICAgIHNldHRpbmdzLmxhbmc7XG4gICAgICAgICAgdGhpcy50aW1lcGlja2VyT2JqID0gdHA7XG4gICAgICAgICAgc2VsZi5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItaW5wdXRcIik7XG5cbiAgICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgICAgICBfcmVuZGVyKHNlbGYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnByb3AoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIik7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zaG93T24pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzZXR0aW5ncy5zaG93T24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uKHNldHRpbmdzLnNob3dPbltpXSArIFwiLnRpbWVwaWNrZXJcIiwgbWV0aG9kcy5zaG93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLm9uKFwiY2hhbmdlLnRpbWVwaWNrZXJcIiwgdHAuX2hhbmRsZUZvcm1hdFZhbHVlKTtcbiAgICAgICAgICAgIHNlbGYub24oXCJrZXlkb3duLnRpbWVwaWNrZXJcIiwgX2tleWRvd25oYW5kbGVyKTtcbiAgICAgICAgICAgIHNlbGYub24oXCJrZXl1cC50aW1lcGlja2VyXCIsIHRwLl9oYW5kbGVLZXlVcCk7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kaXNhYmxlVGV4dElucHV0KSB7XG4gICAgICAgICAgICAgIHNlbGYub24oXCJrZXlkb3duLnRpbWVwaWNrZXJcIiwgdHAuX2Rpc2FibGVUZXh0SW5wdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5vbihcImN1dC50aW1lcGlja2VyXCIsIHRwLl9oYW5kbGVLZXlVcCk7XG4gICAgICAgICAgICBzZWxmLm9uKFwicGFzdGUudGltZXBpY2tlclwiLCB0cC5faGFuZGxlS2V5VXApO1xuXG4gICAgICAgICAgICB0cC5fZm9ybWF0VmFsdWUobnVsbCwgXCJpbml0aWFsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdyhlKSB7XG4gICAgICAgIHZhciBzZWxmID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIHRwID0gc2VsZlswXS50aW1lcGlja2VyT2JqO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0cC5zZXR0aW5ncztcblxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy51c2VTZWxlY3QpIHtcbiAgICAgICAgICB0cC5saXN0LnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRwLl9oaWRlS2V5Ym9hcmQoKSkge1xuICAgICAgICAgIC8vIGJsb2NrIHRoZSBrZXlib2FyZCBvbiBtb2JpbGUgZGV2aWNlc1xuICAgICAgICAgIHNlbGYudHJpZ2dlcignYmx1cicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3QgPSB0cC5saXN0OyAvLyBjaGVjayBpZiBpbnB1dCBpcyByZWFkb25seVxuXG4gICAgICAgIGlmIChzZWxmLnByb3AoXCJyZWFkb25seVwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBjaGVjayBpZiBsaXN0IG5lZWRzIHRvIGJlIHJlbmRlcmVkXG5cblxuICAgICAgICBfcmVuZGVyKHNlbGYpO1xuXG4gICAgICAgIGxpc3QgPSB0cC5saXN0O1xuXG4gICAgICAgIGlmIChUaW1lcGlja2VyLmlzVmlzaWJsZShsaXN0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmlzKCdpbnB1dCcpKSB7XG4gICAgICAgICAgdHAuc2VsZWN0ZWRWYWx1ZSA9IHNlbGYudmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cC5fc2V0U2VsZWN0ZWQoKTsgLy8gbWFrZSBzdXJlIG90aGVyIHBpY2tlcnMgYXJlIGhpZGRlblxuXG5cbiAgICAgICAgVGltZXBpY2tlci5oaWRlQWxsKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5saXN0V2lkdGggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGxpc3Qud2lkdGgoc2VsZi5vdXRlcldpZHRoKCkgKiBzZXR0aW5ncy5saXN0V2lkdGgpO1xuICAgICAgICB9IC8vIHBvc2l0aW9uIHRoZSBkcm9wZG93biByZWxhdGl2ZSB0byB0aGUgaW5wdXRcblxuXG4gICAgICAgIGxpc3Quc2hvdygpO1xuICAgICAgICB2YXIgbGlzdE9mZnNldCA9IHt9O1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5vcmllbnRhdGlvbi5tYXRjaCgvci8pKSB7XG4gICAgICAgICAgLy8gcmlnaHQtYWxpZ24gdGhlIGRyb3Bkb3duXG4gICAgICAgICAgbGlzdE9mZnNldC5sZWZ0ID0gc2VsZi5vZmZzZXQoKS5sZWZ0ICsgc2VsZi5vdXRlcldpZHRoKCkgLSBsaXN0Lm91dGVyV2lkdGgoKSArIHBhcnNlSW50KGxpc3QuY3NzKFwibWFyZ2luTGVmdFwiKS5yZXBsYWNlKFwicHhcIiwgXCJcIiksIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5vcmllbnRhdGlvbi5tYXRjaCgvbC8pKSB7XG4gICAgICAgICAgLy8gbGVmdC1hbGlnbiB0aGUgZHJvcGRvd25cbiAgICAgICAgICBsaXN0T2Zmc2V0LmxlZnQgPSBzZWxmLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludChsaXN0LmNzcyhcIm1hcmdpbkxlZnRcIikucmVwbGFjZShcInB4XCIsIFwiXCIpLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub3JpZW50YXRpb24ubWF0Y2goL2MvKSkge1xuICAgICAgICAgIC8vIGNlbnRlci1hbGlnbiB0aGUgZHJvcGRvd25cbiAgICAgICAgICBsaXN0T2Zmc2V0LmxlZnQgPSBzZWxmLm9mZnNldCgpLmxlZnQgKyAoc2VsZi5vdXRlcldpZHRoKCkgLSBsaXN0Lm91dGVyV2lkdGgoKSkgLyAyICsgcGFyc2VJbnQobGlzdC5jc3MoXCJtYXJnaW5MZWZ0XCIpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRpY2FsT3JpZW50YXRpb247XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLm9yaWVudGF0aW9uLm1hdGNoKC90LykpIHtcbiAgICAgICAgICB2ZXJ0aWNhbE9yaWVudGF0aW9uID0gXCJ0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub3JpZW50YXRpb24ubWF0Y2goL2IvKSkge1xuICAgICAgICAgIHZlcnRpY2FsT3JpZW50YXRpb24gPSBcImJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLm9mZnNldCgpLnRvcCArIHNlbGYub3V0ZXJIZWlnaHQodHJ1ZSkgKyBsaXN0Lm91dGVySGVpZ2h0KCkgPiAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICB2ZXJ0aWNhbE9yaWVudGF0aW9uID0gXCJ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVydGljYWxPcmllbnRhdGlvbiA9IFwiYlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnRpY2FsT3JpZW50YXRpb24gPT0gXCJ0XCIpIHtcbiAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgZHJvcGRvd24gb24gdG9wXG4gICAgICAgICAgbGlzdC5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItcG9zaXRpb25lZC10b3BcIik7XG4gICAgICAgICAgbGlzdE9mZnNldC50b3AgPSBzZWxmLm9mZnNldCgpLnRvcCAtIGxpc3Qub3V0ZXJIZWlnaHQoKSArIHBhcnNlSW50KGxpc3QuY3NzKFwibWFyZ2luVG9wXCIpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHB1dCBpdCB1bmRlciB0aGUgaW5wdXRcbiAgICAgICAgICBsaXN0LnJlbW92ZUNsYXNzKFwidWktdGltZXBpY2tlci1wb3NpdGlvbmVkLXRvcFwiKTtcbiAgICAgICAgICBsaXN0T2Zmc2V0LnRvcCA9IHNlbGYub2Zmc2V0KCkudG9wICsgc2VsZi5vdXRlckhlaWdodCgpICsgcGFyc2VJbnQobGlzdC5jc3MoXCJtYXJnaW5Ub3BcIikucmVwbGFjZShcInB4XCIsIFwiXCIpLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0Lm9mZnNldChsaXN0T2Zmc2V0KTsgLy8gcG9zaXRpb24gc2Nyb2xsaW5nXG5cbiAgICAgICAgdmFyIHNlbGVjdGVkID0gbGlzdC5maW5kKFwiLnVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG5cbiAgICAgICAgaWYgKCFzZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdGltZUludCA9IHRwLmFueXRpbWUyaW50KHRwLl9nZXRUaW1lVmFsdWUoKSk7XG5cbiAgICAgICAgICBpZiAodGltZUludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSAkKHRwLl9maW5kUm93KHRpbWVJbnQpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNjcm9sbERlZmF1bHQoKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSAkKHRwLl9maW5kUm93KHNldHRpbmdzLnNjcm9sbERlZmF1bHQoKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBub3QgZm91bmQgb3IgZGlzYWJsZWQsIGludGVsbGlnZW50bHkgZmluZCBmaXJzdCBzZWxlY3RhYmxlIGVsZW1lbnRcblxuXG4gICAgICAgIGlmICghc2VsZWN0ZWQubGVuZ3RoIHx8IHNlbGVjdGVkLmhhc0NsYXNzKFwidWktdGltZXBpY2tlci1kaXNhYmxlZFwiKSkge1xuICAgICAgICAgIHNlbGVjdGVkID0gbGlzdC5maW5kKFwibGk6bm90KC51aS10aW1lcGlja2VyLWRpc2FibGVkKTpmaXJzdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gbGlzdC5zY3JvbGxUb3AoKSArIHNlbGVjdGVkLnBvc2l0aW9uKCkudG9wIC0gc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICBsaXN0LnNjcm9sbFRvcCh0b3BPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3Quc2Nyb2xsVG9wKDApO1xuICAgICAgICB9IC8vIHByZXZlbnQgc2Nyb2xsIHByb3BhZ2F0aW9uXG5cblxuICAgICAgICBpZiAoc2V0dGluZ3Muc3RvcFNjcm9sbFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgJChkb2N1bWVudCkub24oXCJ3aGVlbC51aS10aW1lcGlja2VyXCIsIFwiLnVpLXRpbWVwaWNrZXItd3JhcHBlclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGwgPSAkKHRoaXMpLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgJCh0aGlzKS5zY3JvbGxUb3AoY3VycmVudFNjcm9sbCArIGUub3JpZ2luYWxFdmVudC5kZWx0YVkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIGF0dGFjaCBjbG9zZSBoYW5kbGVyc1xuXG5cbiAgICAgICAgJChkb2N1bWVudCkub24oXCJtb3VzZWRvd24udWktdGltZXBpY2tlclwiLCBfY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIF9jbG9zZUhhbmRsZXIpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jbG9zZU9uV2luZG93U2Nyb2xsKSB7XG4gICAgICAgICAgJChkb2N1bWVudCkub24oXCJzY3JvbGwudWktdGltZXBpY2tlclwiLCBfY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYudHJpZ2dlcihcInNob3dUaW1lcGlja2VyXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKGUpIHtcbiAgICAgICAgdmFyIHRwID0gdGhpc1swXS50aW1lcGlja2VyT2JqO1xuXG4gICAgICAgIGlmICh0cCkge1xuICAgICAgICAgIHRwLmhpZGVNZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgVGltZXBpY2tlci5oaWRlQWxsKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHZhciB0cCA9IHRoaXNbMF0udGltZXBpY2tlck9iajtcbiAgICAgICAgICByZXR1cm4gdHAuc2V0dGluZ3Nba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gJCh0aGlzKTtcbiAgICAgICAgICB2YXIgdHAgPSBzZWxmWzBdLnRpbWVwaWNrZXJPYmo7XG4gICAgICAgICAgdmFyIHNldHRpbmdzID0gdHAuc2V0dGluZ3M7XG4gICAgICAgICAgdmFyIGxpc3QgPSB0cC5saXN0O1xuXG4gICAgICAgICAgaWYgKF90eXBlb2Yoa2V5KSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHNldHRpbmdzLCBrZXkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0dGluZ3MgPSB0cC5wYXJzZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICB0cC5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgICAgICAgdHAuX2Zvcm1hdFZhbHVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hhbmdlXCJcbiAgICAgICAgICB9LCBcImluaXRpYWxcIik7XG5cbiAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgbGlzdC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRwLmxpc3QgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZXR0aW5ncy51c2VTZWxlY3QpIHtcbiAgICAgICAgICAgIF9yZW5kZXIoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRTZWNvbmRzRnJvbU1pZG5pZ2h0OiBmdW5jdGlvbiBnZXRTZWNvbmRzRnJvbU1pZG5pZ2h0KCkge1xuICAgICAgICB2YXIgdHAgPSB0aGlzWzBdLnRpbWVwaWNrZXJPYmo7XG4gICAgICAgIHJldHVybiB0cC5hbnl0aW1lMmludCh0cC5fZ2V0VGltZVZhbHVlKCkpO1xuICAgICAgfSxcbiAgICAgIGdldFRpbWU6IGZ1bmN0aW9uIGdldFRpbWUocmVsYXRpdmVfZGF0ZSkge1xuICAgICAgICB2YXIgdHAgPSB0aGlzWzBdLnRpbWVwaWNrZXJPYmo7XG5cbiAgICAgICAgdmFyIHRpbWVfc3RyaW5nID0gdHAuX2dldFRpbWVWYWx1ZSgpO1xuXG4gICAgICAgIGlmICghdGltZV9zdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSB0cC5hbnl0aW1lMmludCh0aW1lX3N0cmluZyk7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWxhdGl2ZV9kYXRlKSB7XG4gICAgICAgICAgcmVsYXRpdmVfZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH0gLy8gY29uc3RydWN0IGEgRGF0ZSBmcm9tIHJlbGF0aXZlIGRhdGUsIGFuZCBvZmZzZXQncyB0aW1lXG5cblxuICAgICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKHJlbGF0aXZlX2RhdGUpO1xuICAgICAgICB0aW1lLnNldEhvdXJzKG9mZnNldCAvIDM2MDApO1xuICAgICAgICB0aW1lLnNldE1pbnV0ZXMob2Zmc2V0ICUgMzYwMCAvIDYwKTtcbiAgICAgICAgdGltZS5zZXRTZWNvbmRzKG9mZnNldCAlIDYwKTtcbiAgICAgICAgdGltZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgIHJldHVybiB0aW1lO1xuICAgICAgfSxcbiAgICAgIGlzVmlzaWJsZTogZnVuY3Rpb24gaXNWaXNpYmxlKCkge1xuICAgICAgICB2YXIgdHAgPSB0aGlzWzBdLnRpbWVwaWNrZXJPYmo7XG4gICAgICAgIHJldHVybiAhISh0cCAmJiB0cC5saXN0ICYmIFRpbWVwaWNrZXIuaXNWaXNpYmxlKHRwLmxpc3QpKTtcbiAgICAgIH0sXG4gICAgICBzZXRUaW1lOiBmdW5jdGlvbiBzZXRUaW1lKHZhbHVlKSB7XG4gICAgICAgIHZhciB0cCA9IHRoaXNbMF0udGltZXBpY2tlck9iajtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdHAuc2V0dGluZ3M7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmZvcmNlUm91bmRUaW1lKSB7XG4gICAgICAgICAgdmFyIHByZXR0eVRpbWUgPSB0cC5fcm91bmRBbmRGb3JtYXRUaW1lKHRwLmFueXRpbWUyaW50KHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXR0eVRpbWUgPSB0cC5faW50MnRpbWUodHAuYW55dGltZTJpbnQodmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBwcmV0dHlUaW1lID09PSBudWxsICYmIHNldHRpbmdzLm5vbmVPcHRpb24pIHtcbiAgICAgICAgICBwcmV0dHlUaW1lID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB0cC5fc2V0VGltZVZhbHVlKHByZXR0eVRpbWUsIFwiaW5pdGlhbFwiKTtcblxuICAgICAgICB0cC5fZm9ybWF0VmFsdWUoe1xuICAgICAgICAgIHR5cGU6IFwiY2hhbmdlXCJcbiAgICAgICAgfSwgXCJpbml0aWFsXCIpO1xuXG4gICAgICAgIGlmICh0cCAmJiB0cC5saXN0KSB7XG4gICAgICAgICAgdHAuX3NldFNlbGVjdGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBjaGVjayBpZiB0aGlzIGVsZW1lbnQgaXMgYSB0aW1lcGlja2VyXG5cbiAgICAgICAgaWYgKCFzZWxmLmhhc0NsYXNzKFwidWktdGltZXBpY2tlci1pbnB1dFwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cCA9IHNlbGZbMF0udGltZXBpY2tlck9iajtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdHAuc2V0dGluZ3M7XG4gICAgICAgIHNlbGYucmVtb3ZlQXR0cihcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiKTtcbiAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyhcInVpLXRpbWVwaWNrZXItaW5wdXRcIik7XG4gICAgICAgIHNlbGYucmVtb3ZlRGF0YShcInRpbWVwaWNrZXItb2JqXCIpO1xuICAgICAgICBzZWxmLm9mZihcIi50aW1lcGlja2VyXCIpOyAvLyB0aW1lcGlja2VyLWxpc3Qgd29uJ3QgYmUgcHJlc2VudCB1bmxlc3MgdGhlIHVzZXIgaGFzIGludGVyYWN0ZWQgd2l0aCB0aGlzIHRpbWVwaWNrZXJcblxuICAgICAgICBpZiAodHAubGlzdCkge1xuICAgICAgICAgIHRwLmxpc3QucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cC5saXN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTsgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICBmdW5jdGlvbiBfcmVuZGVyKHNlbGYpIHtcbiAgICAgIHZhciBfc2V0dGluZ3MkZHVyYXRpb25UaW0sIF9zZXR0aW5ncyRtaW5UaW1lLCBfc2V0dGluZ3MkbWF4VGltZTtcblxuICAgICAgdmFyIHRwID0gc2VsZlswXS50aW1lcGlja2VyT2JqO1xuICAgICAgdmFyIGxpc3QgPSB0cC5saXN0O1xuICAgICAgdmFyIHNldHRpbmdzID0gdHAuc2V0dGluZ3M7XG5cbiAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoKSB7XG4gICAgICAgIGxpc3QucmVtb3ZlKCk7XG4gICAgICAgIHRwLmxpc3QgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgIGxpc3QgPSAkKFwiPHNlbGVjdD48L3NlbGVjdD5cIiwge1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJ1aS10aW1lcGlja2VyLXNlbGVjdFwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxmLmF0dHIoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgbGlzdC5hdHRyKFwibmFtZVwiLCBcInVpLXRpbWVwaWNrZXItXCIgKyBzZWxmLmF0dHIoXCJuYW1lXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3cmFwcGVkX2xpc3QgPSBsaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdCA9ICQoXCI8dWw+PC91bD5cIiwge1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJ1aS10aW1lcGlja2VyLWxpc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdyYXBwZWRfbGlzdCA9ICQoXCI8ZGl2PjwvZGl2PlwiLCB7XG4gICAgICAgICAgXCJjbGFzc1wiOiBcInVpLXRpbWVwaWNrZXItd3JhcHBlclwiLFxuICAgICAgICAgIHRhYmluZGV4OiAtMVxuICAgICAgICB9KTtcbiAgICAgICAgd3JhcHBlZF9saXN0LmNzcyh7XG4gICAgICAgICAgZGlzcGxheTogXCJub25lXCIsXG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9KS5hcHBlbmQobGlzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncy5ub25lT3B0aW9uKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5ub25lT3B0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgc2V0dGluZ3Mubm9uZU9wdGlvbiA9IHNldHRpbmdzLnVzZVNlbGVjdCA/IFwiVGltZS4uLlwiIDogXCJOb25lXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJC5pc0FycmF5KHNldHRpbmdzLm5vbmVPcHRpb24pKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBzZXR0aW5ncy5ub25lT3B0aW9uKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VJbnQoaSwgMTApID09IGkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vbmVFbGVtZW50ID0gdHAuX2dlbmVyYXRlTm9uZUVsZW1lbnQoc2V0dGluZ3Mubm9uZU9wdGlvbltpXSwgc2V0dGluZ3MudXNlU2VsZWN0KTtcblxuICAgICAgICAgICAgICBsaXN0LmFwcGVuZChub25lRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBub25lRWxlbWVudCA9IHRwLl9nZW5lcmF0ZU5vbmVFbGVtZW50KHNldHRpbmdzLm5vbmVPcHRpb24sIHNldHRpbmdzLnVzZVNlbGVjdCk7XG5cbiAgICAgICAgICBsaXN0LmFwcGVuZChub25lRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmNsYXNzTmFtZSkge1xuICAgICAgICB3cmFwcGVkX2xpc3QuYWRkQ2xhc3Moc2V0dGluZ3MuY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzZXR0aW5ncy5taW5UaW1lICE9PSBudWxsIHx8IHNldHRpbmdzLmR1cmF0aW9uVGltZSAhPT0gbnVsbCkgJiYgc2V0dGluZ3Muc2hvd0R1cmF0aW9uKSB7XG4gICAgICAgIHR5cGVvZiBzZXR0aW5ncy5zdGVwID09IFwiZnVuY3Rpb25cIiA/IFwiZnVuY3Rpb25cIiA6IHNldHRpbmdzLnN0ZXA7XG4gICAgICAgIHdyYXBwZWRfbGlzdC5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItd2l0aC1kdXJhdGlvblwiKTtcbiAgICAgICAgd3JhcHBlZF9saXN0LmFkZENsYXNzKFwidWktdGltZXBpY2tlci1zdGVwLVwiICsgc2V0dGluZ3Muc3RlcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJTdGFydCA9IChfc2V0dGluZ3MkZHVyYXRpb25UaW0gPSBzZXR0aW5ncy5kdXJhdGlvblRpbWUoKSkgIT09IG51bGwgJiYgX3NldHRpbmdzJGR1cmF0aW9uVGltICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkZHVyYXRpb25UaW0gOiBzZXR0aW5ncy5taW5UaW1lKCk7XG4gICAgICB2YXIgc3RhcnQgPSAoX3NldHRpbmdzJG1pblRpbWUgPSBzZXR0aW5ncy5taW5UaW1lKCkpICE9PSBudWxsICYmIF9zZXR0aW5ncyRtaW5UaW1lICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkbWluVGltZSA6IDA7XG4gICAgICB2YXIgZW5kID0gKF9zZXR0aW5ncyRtYXhUaW1lID0gc2V0dGluZ3MubWF4VGltZSgpKSAhPT0gbnVsbCAmJiBfc2V0dGluZ3MkbWF4VGltZSAhPT0gdm9pZCAwID8gX3NldHRpbmdzJG1heFRpbWUgOiBzdGFydCArIE9ORV9EQVkgLSAxO1xuXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBlbmQgdGltZSBpcyBncmVhdGVyIHRoYW4gc3RhcnQgdGltZSwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgbm8gbGlzdCB0byBzaG93XG4gICAgICAgIGVuZCArPSBPTkVfREFZO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSBPTkVfREFZIC0gMSAmJiAkLnR5cGUoc2V0dGluZ3MudGltZUZvcm1hdCkgPT09IFwic3RyaW5nXCIgJiYgc2V0dGluZ3Muc2hvdzI0MDApIHtcbiAgICAgICAgLy8gc2hvdyBhIDI0OjAwIG9wdGlvbiB3aGVuIHVzaW5nIG1pbGl0YXJ5IHRpbWVcbiAgICAgICAgZW5kID0gT05FX0RBWTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRyID0gc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXM7XG4gICAgICB2YXIgZHJDdXIgPSAwO1xuICAgICAgdmFyIGRyTGVuID0gZHIubGVuZ3RoO1xuICAgICAgdmFyIHN0ZXBGdW5jID0gc2V0dGluZ3Muc3RlcDtcblxuICAgICAgaWYgKHR5cGVvZiBzdGVwRnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RlcEZ1bmMgPSBmdW5jdGlvbiBzdGVwRnVuYygpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc3RlcDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gMDsgaSA8PSBlbmQ7IGorKywgaSArPSBzdGVwRnVuYyhqKSAqIDYwKSB7XG4gICAgICAgIHZhciB0aW1lSW50ID0gaTtcblxuICAgICAgICB2YXIgdGltZVN0cmluZyA9IHRwLl9pbnQydGltZSh0aW1lSW50KTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgICAgdmFyIHJvdyA9ICQoXCI8b3B0aW9uPjwvb3B0aW9uPlwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGltZVN0cmluZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJvdy50ZXh0KHRpbWVTdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByb3cgPSAkKFwiPGxpPjwvbGk+XCIpO1xuICAgICAgICAgIHJvdy5hZGRDbGFzcyh0aW1lSW50ICUgT05FX0RBWSA8IE9ORV9EQVkgLyAyID8gXCJ1aS10aW1lcGlja2VyLWFtXCIgOiBcInVpLXRpbWVwaWNrZXItcG1cIik7XG4gICAgICAgICAgcm93LmF0dHIoXCJkYXRhLXRpbWVcIiwgcm91bmRpbmdGdW5jdGlvbih0aW1lSW50LCBzZXR0aW5ncykpO1xuICAgICAgICAgIHJvdy50ZXh0KHRpbWVTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChzZXR0aW5ncy5taW5UaW1lKCkgIT09IG51bGwgfHwgc2V0dGluZ3MuZHVyYXRpb25UaW1lKCkgIT09IG51bGwpICYmIHNldHRpbmdzLnNob3dEdXJhdGlvbikge1xuICAgICAgICAgIHZhciBkdXJhdGlvblN0cmluZyA9IHRwLl9pbnQyZHVyYXRpb24oaSAtIGR1clN0YXJ0LCBzZXR0aW5ncy5zdGVwKTtcblxuICAgICAgICAgIGlmIChzZXR0aW5ncy51c2VTZWxlY3QpIHtcbiAgICAgICAgICAgIHJvdy50ZXh0KHJvdy50ZXh0KCkgKyBcIiAoXCIgKyBkdXJhdGlvblN0cmluZyArIFwiKVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gJChcIjxzcGFuPjwvc3Bhbj5cIiwge1xuICAgICAgICAgICAgICBcImNsYXNzXCI6IFwidWktdGltZXBpY2tlci1kdXJhdGlvblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGR1cmF0aW9uLnRleHQoXCIgKFwiICsgZHVyYXRpb25TdHJpbmcgKyBcIilcIik7XG4gICAgICAgICAgICByb3cuYXBwZW5kKGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJDdXIgPCBkckxlbikge1xuICAgICAgICAgIGlmICh0aW1lSW50ID49IGRyW2RyQ3VyXVsxXSkge1xuICAgICAgICAgICAgZHJDdXIgKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZHJbZHJDdXJdICYmIHRpbWVJbnQgPj0gZHJbZHJDdXJdWzBdICYmIHRpbWVJbnQgPCBkcltkckN1cl1bMV0pIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy51c2VTZWxlY3QpIHtcbiAgICAgICAgICAgICAgcm93LnByb3AoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJvdy5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItZGlzYWJsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5hcHBlbmQocm93KTtcbiAgICAgIH1cblxuICAgICAgd3JhcHBlZF9saXN0LmRhdGEoXCJ0aW1lcGlja2VyLWlucHV0XCIsIHNlbGYpO1xuICAgICAgdHAubGlzdCA9IHdyYXBwZWRfbGlzdDtcblxuICAgICAgaWYgKHNldHRpbmdzLnVzZVNlbGVjdCkge1xuICAgICAgICBpZiAoc2VsZi52YWwoKSkge1xuICAgICAgICAgIGxpc3QudmFsKHRwLl9yb3VuZEFuZEZvcm1hdFRpbWUodHAuYW55dGltZTJpbnQoc2VsZi52YWwoKSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3Qub24oXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKFwidGltZXBpY2tlci1pbnB1dFwiKS50cmlnZ2VyKFwic2hvd1RpbWVwaWNrZXJcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0Lm9uKFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJCh0aGlzKS5kYXRhKFwidGltZXBpY2tlci1pbnB1dFwiKS50cmlnZ2VyKFwiaGlkZVRpbWVwaWNrZXJcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0Lm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cC5fc2V0VGltZVZhbHVlKCQodGhpcykudmFsKCksIFwic2VsZWN0XCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cC5fc2V0VGltZVZhbHVlKGxpc3QudmFsKCksIFwiaW5pdGlhbFwiKTtcblxuICAgICAgICBzZWxmLmhpZGUoKS5hZnRlcihsaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcHBlbmRUbyA9IHNldHRpbmdzLmFwcGVuZFRvO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBhcHBlbmRUbyA9ICQoYXBwZW5kVG8pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcHBlbmRUbyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgYXBwZW5kVG8gPSBhcHBlbmRUbyhzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZFRvLmFwcGVuZCh3cmFwcGVkX2xpc3QpO1xuXG4gICAgICAgIHRwLl9zZXRTZWxlY3RlZCgpO1xuXG4gICAgICAgIGxpc3Qub24oXCJtb3VzZWRvd24gY2xpY2tcIiwgXCJsaVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIGhhY2s6IHRlbXBvcmFyaWx5IGRpc2FibGUgdGhlIGZvY3VzIGhhbmRsZXJcbiAgICAgICAgICAvLyB0byBkZWFsIHdpdGggdGhlIGZhY3QgdGhhdCBJRSBmaXJlcyAnZm9jdXMnXG4gICAgICAgICAgLy8gZXZlbnRzIGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgc2VsZi5vZmYoXCJmb2N1cy50aW1lcGlja2VyXCIpO1xuICAgICAgICAgIHNlbGYub24oXCJmb2N1cy50aW1lcGlja2VyLWllLWhhY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vZmYoXCJmb2N1cy50aW1lcGlja2VyLWllLWhhY2tcIik7XG4gICAgICAgICAgICBzZWxmLm9uKFwiZm9jdXMudGltZXBpY2tlclwiLCBtZXRob2RzLnNob3cpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCF0cC5faGlkZUtleWJvYXJkKCkpIHtcbiAgICAgICAgICAgIHNlbGZbMF0uZm9jdXMoKTtcbiAgICAgICAgICB9IC8vIG1ha2Ugc3VyZSBvbmx5IHRoZSBjbGlja2VkIHJvdyBpcyBzZWxlY3RlZFxuXG5cbiAgICAgICAgICBsaXN0LmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG4gICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG5cbiAgICAgICAgICBpZiAodHAuX3NlbGVjdFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihcImhpZGVUaW1lcGlja2VyXCIpO1xuICAgICAgICAgICAgbGlzdC5vbihcIm1vdXNldXAudGltZXBpY2tlciBjbGljay50aW1lcGlja2VyXCIsIFwibGlcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgbGlzdC5vZmYoXCJtb3VzZXVwLnRpbWVwaWNrZXIgY2xpY2sudGltZXBpY2tlclwiKTtcbiAgICAgICAgICAgICAgd3JhcHBlZF9saXN0LmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBldmVudCBoYW5kbGVyIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGNsb3NlIHRpbWVwaWNrZXJcblxuXG4gICAgZnVuY3Rpb24gX2Nsb3NlSGFuZGxlcihlKSB7XG4gICAgICBpZiAoZS50eXBlID09ICdmb2N1cycgJiYgZS50YXJnZXQgPT0gd2luZG93KSB7XG4gICAgICAgIC8vIG1vYmlsZSBDaHJvbWUgZmlyZXMgZm9jdXMgZXZlbnRzIGFnYWluc3Qgd2luZG93IGZvciBzb21lIHJlYXNvblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXQgPSAkKGUudGFyZ2V0KTtcblxuICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KFwiLnVpLXRpbWVwaWNrZXItaW5wdXRcIikubGVuZ3RoIHx8IHRhcmdldC5jbG9zZXN0KFwiLnVpLXRpbWVwaWNrZXItd3JhcHBlclwiKS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWN0aXZlIHRpbWVwaWNrZXIgd2FzIGZvY3VzZWQuIGlnbm9yZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIFRpbWVwaWNrZXIuaGlkZUFsbCgpO1xuICAgICAgJChkb2N1bWVudCkudW5iaW5kKFwiLnVpLXRpbWVwaWNrZXJcIik7XG4gICAgICAkKHdpbmRvdykudW5iaW5kKFwiLnVpLXRpbWVwaWNrZXJcIik7XG4gICAgfVxuICAgIC8qXG4gICAgICogIEtleWJvYXJkIG5hdmlnYXRpb24gdmlhIGFycm93IGtleXNcbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gX2tleWRvd25oYW5kbGVyKGUpIHtcbiAgICAgIHZhciBzZWxmID0gJCh0aGlzKTtcbiAgICAgIHZhciB0cCA9IHNlbGZbMF0udGltZXBpY2tlck9iajtcbiAgICAgIHZhciBsaXN0ID0gdHAubGlzdDtcblxuICAgICAgaWYgKCFsaXN0IHx8ICFUaW1lcGlja2VyLmlzVmlzaWJsZShsaXN0KSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDQwKSB7XG4gICAgICAgICAgLy8gc2hvdyB0aGUgbGlzdCFcbiAgICAgICAgICBtZXRob2RzLnNob3cuY2FsbChzZWxmLmdldCgwKSk7XG4gICAgICAgICAgbGlzdCA9IHRwLmxpc3Q7XG5cbiAgICAgICAgICBpZiAoIXRwLl9oaWRlS2V5Ym9hcmQoKSkge1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIC8vIHJldHVyblxuICAgICAgICAgIGlmICh0cC5fc2VsZWN0VmFsdWUoKSkge1xuICAgICAgICAgICAgdHAuX2Zvcm1hdFZhbHVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjaGFuZ2VcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRwLmhpZGVNZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAvLyB1cFxuICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGxpc3QuZmluZChcIi51aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuXG4gICAgICAgICAgaWYgKCFzZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpc3QuZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24gKGksIG9iaikge1xuICAgICAgICAgICAgICBpZiAoJChvYmopLnBvc2l0aW9uKCkudG9wID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gJChvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZC5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghc2VsZWN0ZWQuaXMoXCI6Zmlyc3QtY2hpbGRcIikpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnJlbW92ZUNsYXNzKFwidWktdGltZXBpY2tlci1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIHNlbGVjdGVkLnByZXYoKS5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZC5wcmV2KCkucG9zaXRpb24oKS50b3AgPCBzZWxlY3RlZC5vdXRlckhlaWdodCgpKSB7XG4gICAgICAgICAgICAgIGxpc3Quc2Nyb2xsVG9wKGxpc3Quc2Nyb2xsVG9wKCkgLSBzZWxlY3RlZC5vdXRlckhlaWdodCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAvLyBkb3duXG4gICAgICAgICAgc2VsZWN0ZWQgPSBsaXN0LmZpbmQoXCIudWktdGltZXBpY2tlci1zZWxlY3RlZFwiKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpc3QuZmluZChcImxpXCIpLmVhY2goZnVuY3Rpb24gKGksIG9iaikge1xuICAgICAgICAgICAgICBpZiAoJChvYmopLnBvc2l0aW9uKCkudG9wID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gJChvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZC5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghc2VsZWN0ZWQuaXMoXCI6bGFzdC1jaGlsZFwiKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQucmVtb3ZlQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgc2VsZWN0ZWQubmV4dCgpLmFkZENsYXNzKFwidWktdGltZXBpY2tlci1zZWxlY3RlZFwiKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLm5leHQoKS5wb3NpdGlvbigpLnRvcCArIDIgKiBzZWxlY3RlZC5vdXRlckhlaWdodCgpID4gbGlzdC5vdXRlckhlaWdodCgpKSB7XG4gICAgICAgICAgICAgIGxpc3Quc2Nyb2xsVG9wKGxpc3Quc2Nyb2xsVG9wKCkgKyBzZWxlY3RlZC5vdXRlckhlaWdodCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICBsaXN0LmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG4gICAgICAgICAgdHAuaGlkZU1lKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIC8vdGFiXG4gICAgICAgICAgdHAuaGlkZU1lKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFBsdWdpbiBlbnRyeVxuXG5cbiAgICAkLmZuLnRpbWVwaWNrZXIgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGVsZW1lbnQgaXMgYSB0aW1lcGlja2VyXG4gICAgICAgIGlmICghdGhpcy5oYXNDbGFzcyhcInVpLXRpbWVwaWNrZXItaW5wdXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2RzW21ldGhvZF0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YobWV0aG9kKSA9PT0gXCJvYmplY3RcIiB8fCAhbWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQuZXJyb3IoXCJNZXRob2QgXCIgKyBtZXRob2QgKyBcIiBkb2VzIG5vdCBleGlzdCBvbiBqUXVlcnkudGltZXBpY2tlclwiKTtcbiAgICAgIH1cbiAgICB9OyAvLyBEZWZhdWx0IHBsdWdpbiBvcHRpb25zLlxuXG5cbiAgICAkLmZuLnRpbWVwaWNrZXIuZGVmYXVsdHMgPSBERUZBVUxUX1NFVFRJTkdTO1xuICB9KTtcblxufSgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/timepicker/jquery.timepicker.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"jQuery\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUNBQW1DLEVBQUUiLCJmaWxlIjoianF1ZXJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcImpRdWVyeVwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///jquery\n");

/***/ })

/******/ })));