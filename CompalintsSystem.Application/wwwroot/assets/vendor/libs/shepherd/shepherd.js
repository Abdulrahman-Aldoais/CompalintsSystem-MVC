(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/shepherd/shepherd.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/*! exports provided: Shepherd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Shepherd\", function() { return shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzPzdhODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiIuL2xpYnMvc2hlcGhlcmQvc2hlcGhlcmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2hlcGhlcmQgZnJvbSAnc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZCc7XHJcblxyXG5leHBvcnQgeyBTaGVwaGVyZCB9O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! shepherd.js 8.3.1 */\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return target.propertyIsEnumerable(symbol);\n    }) : [];\n  }\n\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  } // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx) {\n        var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n                handler = binding.handler,\n                once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n\n        return this;\n      }\n    }]);\n\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n\n\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n\n    return self;\n  }\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref5 = step.options.advanceOn || {},\n        event = _ref5.event,\n        selector = _ref5.selector;\n\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n\n      var el;\n\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n\n    return node;\n  }\n\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  } // and applies them to the HTMLElements such as popper and arrow\n\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n\n  function getBoundingClientRect(element) {\n    var rect = element.getBoundingClientRect();\n    return {\n      width: rect.width,\n      height: rect.height,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      x: rect.left,\n      y: rect.top\n    };\n  } // means it doesn't take into account transforms.\n\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n        var next = child;\n\n        do {\n          if (next && parent.isSameNode(next)) {\n            return true;\n          } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n          next = next.parentNode || next.host;\n        } while (next);\n      } // Give up, the result is false\n\n\n    return false;\n  }\n\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n\n    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || ( // DOM Element detected\n      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle(element);\n\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n\n    var currentNode = getParentNode(element);\n\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n      return window;\n    }\n\n    return offsetParent || getContainingBlock(element) || window;\n  }\n\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n\n  function arrow(_ref) {\n    var _state$modifiersData$;\n\n    var state = _ref.state,\n        name = _ref.name,\n        options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options;\n    var _options$element = options.element,\n        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n\n      if (!arrowElement) {\n        return;\n      }\n    }\n\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n        y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(round(x * dpr) / dpr) || 0,\n      y: round(round(y * dpr) / dpr) || 0\n    };\n  }\n\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n\n    var popper = _ref2.popper,\n        popperRect = _ref2.popperRect,\n        placement = _ref2.placement,\n        offsets = _ref2.offsets,\n        position = _ref2.position,\n        gpuAcceleration = _ref2.gpuAcceleration,\n        adaptive = _ref2.adaptive,\n        roundOffsets = _ref2.roundOffsets;\n\n    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\n        _ref3$x = _ref3.x,\n        x = _ref3$x === void 0 ? 0 : _ref3$x,\n        _ref3$y = _ref3.y,\n        y = _ref3$y === void 0 ? 0 : _ref3$y;\n\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n\n        if (getComputedStyle(offsetParent).position !== 'static') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n      offsetParent = offsetParent;\n\n      if (placement === top) {\n        sideY = bottom; // $FlowFixMe[prop-missing]\n\n        y -= offsetParent[heightProp] - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n\n      if (placement === left) {\n        sideX = right; // $FlowFixMe[prop-missing]\n\n        x -= offsetParent[widthProp] - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n\n    if (gpuAcceleration) {\n      var _Object$assign;\n\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n\n  function computeStyles(_ref4) {\n    var state = _ref4.state,\n        options = _ref4.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n        _options$adaptive = options.adaptive,\n        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n        _options$roundOffsets = options.roundOffsets,\n        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration\n    };\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n\n  function effect(_ref) {\n    var state = _ref.state,\n        instance = _ref.instance,\n        options = _ref.options;\n    var _options$scroll = options.scroll,\n        scroll = _options$scroll === void 0 ? true : _options$scroll,\n        _options$resize = options.resize,\n        resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  } // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n\n    if (getComputedStyle(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element),\n        overflow = _getComputedStyle.overflow,\n        overflowX = _getComputedStyle.overflowX,\n        overflowY = _getComputedStyle.overflowY;\n\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n\n    return getScrollParent(getParentNode(node));\n  }\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n\n    if (list === void 0) {\n      list = [];\n    }\n\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n        element = _ref.element,\n        placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n\n    return offsets;\n  }\n\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$placement = _options.placement,\n        placement = _options$placement === void 0 ? state.placement : _options$placement,\n        _options$boundary = _options.boundary,\n        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n        _options$rootBoundary = _options.rootBoundary,\n        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n        _options$elementConte = _options.elementContext,\n        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n        _options$altBoundary = _options.altBoundary,\n        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n        _options$padding = _options.padding,\n        padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var referenceElement = state.elements.reference;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(referenceElement);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n\n    return overflowOffsets;\n  }\n\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        placement = _options.placement,\n        boundary = _options.boundary,\n        rootBoundary = _options.rootBoundary,\n        padding = _options.padding,\n        flipVariations = _options.flipVariations,\n        _options$allowedAutoP = _options.allowedAutoPlacements,\n        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n\n  function flip(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n\n    var _options$mainAxis = options.mainAxis,\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n        _options$altAxis = options.altAxis,\n        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n        specifiedFallbackPlacements = options.fallbackPlacements,\n        padding = options.padding,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        _options$flipVariatio = options.flipVariations,\n        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n        allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n\n      var _basePlacement = getBasePlacement(placement);\n\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n\n      checksMap.set(placement, checks);\n    }\n\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n\n        if (_ret === \"break\") break;\n      }\n    }\n\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n\n  function hide(_ref) {\n    var state = _ref.state,\n        name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n      placement: placement\n    })) : offset,\n        skidding = _ref[0],\n        distance = _ref[1];\n\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n\n  function offset(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options,\n        name = _ref2.name;\n    var _options$offset = options.offset,\n        offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n        x = _data$state$placement.x,\n        y = _data$state$placement.y;\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n        name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n        _options$altAxis = options.altAxis,\n        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        padding = options.padding,\n        _options$tether = options.tether,\n        tether = _options$tether === void 0 ? true : _options$tether,\n        _options$tetherOffset = options.tetherOffset,\n        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var data = {\n      x: 0,\n      y: 0\n    };\n\n    if (!popperOffsets) {\n      return;\n    }\n\n    if (checkMainAxis || checkAltAxis) {\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = popperOffsets[mainAxis] + overflow[mainSide];\n      var max$1 = popperOffsets[mainAxis] - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n      var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n      if (checkMainAxis) {\n        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n      }\n\n      if (checkAltAxis) {\n        var _mainSide = mainAxis === 'x' ? top : left;\n\n        var _altSide = mainAxis === 'x' ? bottom : right;\n\n        var _offset = popperOffsets[altAxis];\n\n        var _min = _offset + overflow[_mainSide];\n\n        var _max = _offset - overflow[_altSide];\n\n        var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);\n\n        popperOffsets[altAxis] = _preventedOffset;\n        data[altAxis] = _preventedOffset - _offset;\n      }\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  } // Composite means it takes into account transforms as well as layout.\n\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement);\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n\n      return pending;\n    };\n  }\n\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n\n    var _generatorOptions = generatorOptions,\n        _generatorOptions$def = _generatorOptions.defaultModifiers,\n        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n        _generatorOptions$def2 = _generatorOptions.defaultOptions,\n        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(options) {\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n\n          var _state$elements = state.elements,\n              reference = _state$elements.reference,\n              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n\n            var _state$orderedModifie = state.orderedModifiers[index],\n                fn = _state$orderedModifie.fn,\n                _state$orderedModifie2 = _state$orderedModifie.options,\n                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n                name = _state$orderedModifie.name;\n\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n              _ref3$options = _ref3.options,\n              options = _ref3$options === void 0 ? {} : _ref3$options,\n              effect = _ref3.effect;\n\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n\n            var noopFn = function noopFn() {};\n\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n\n      return instance;\n    };\n  }\n\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref6) {\n        var state = _ref6.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [{\n        name: 'focusAfterRender',\n        enabled: true,\n        phase: 'afterWrite',\n        fn: function fn() {\n          setTimeout(function () {\n            if (step.el) {\n              step.el.focus();\n            }\n          }, 300);\n        }\n      }]\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(_toConsumableArray(popperOptions.modifiers), _toConsumableArray(centeredStylePopperModifier))))\n    });\n    return popperOptions;\n  }\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n  /**\n   * Checks if options.attachTo.element is a string, and if so, tries to find the element\n   * @param {Step} step The step instance\n   * @returns {{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n\n    if (isString(options.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(options.element);\n      } catch (e) {// TODO\n      }\n\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n\n    return returnOpts;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n\n    var attachToOptions = parseAttachTo(step);\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n\n    if (step.isCentered()) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true,\n          tether: false\n        }\n      }, {\n        name: 'focusAfterRender',\n        enabled: true,\n        phase: 'afterWrite',\n        fn: function fn() {\n          setTimeout(function () {\n            if (step.el) {\n              step.el.focus();\n            }\n          }, 300);\n        }\n      }],\n      strategy: 'absolute'\n    };\n\n    if (step.isCentered()) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(_toConsumableArray(filteredModifiers), _toConsumableArray(stepOptions.popperOptions.modifiers))));\n      }\n\n      return mergedPopperOptions;\n    }\n\n    return popperOptions;\n  }\n\n  function noop() {}\n\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) {\n      tar[k] = src[k];\n    }\n\n    return tar;\n  }\n\n  function run(fn) {\n    return fn();\n  }\n\n  function blank_object() {\n    return Object.create(null);\n  }\n\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n\n  function append(target, node) {\n    target.appendChild(node);\n  }\n\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n\n  function element(name) {\n    return document.createElement(name);\n  }\n\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  function text(data) {\n    return document.createTextNode(data);\n  }\n\n  function space() {\n    return text(' ');\n  }\n\n  function empty() {\n    return text('');\n  }\n\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n\n  var current_component;\n\n  function set_current_component(component) {\n    current_component = component;\n  }\n\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n\n  var flushing = false;\n  var seen_callbacks = new Set();\n\n  function flush() {\n    if (flushing) return;\n    flushing = true;\n\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      for (var i = 0; i < dirty_components.length; i += 1) {\n        var component = dirty_components[i];\n        set_current_component(component);\n        update(component.$$);\n      }\n\n      set_current_component(null);\n      dirty_components.length = 0;\n\n      while (binding_callbacks.length) {\n        binding_callbacks.pop()();\n      } // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n\n      for (var _i2 = 0; _i2 < render_callbacks.length; _i2 += 1) {\n        var callback = render_callbacks[_i2];\n\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n  }\n\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n\n  var outroing = new Set();\n  var outros;\n\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n\n    outros = outros.p;\n  }\n\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    }\n  }\n\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n\n        for (var _key3 in n) {\n          if (!accounted_for[_key3]) {\n            update[_key3] = n[_key3];\n            accounted_for[_key3] = 1;\n          }\n        }\n\n        levels[i] = n;\n      } else {\n        for (var _key4 in o) {\n          accounted_for[_key4] = 1;\n        }\n      }\n    }\n\n    for (var _key5 in to_null_out) {\n      if (!(_key5 in update)) update[_key5] = undefined;\n    }\n\n    return update;\n  }\n\n  function create_component(block) {\n    block && block.c();\n  }\n\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n        fragment = _component$$$.fragment,\n        on_mount = _component$$$.on_mount,\n        on_destroy = _component$$$.on_destroy,\n        after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = on_mount.map(run).filter(is_function);\n\n        if (on_destroy) {\n          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n\n        component.$$.on_mount = [];\n      });\n    }\n\n    after_update.forEach(add_render_callback);\n  }\n\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n\n  function init(component, options, instance, create_fragment, not_equal, props) {\n    var dirty = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [-1];\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false\n    };\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n\n\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*label*/\n        ctx[3] ?\n        /*label*/\n        ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat(\n        /*classes*/\n        ctx[1] || \"\", \" shepherd-button \").concat(\n        /*secondary*/\n        ctx[4] ? \"shepherd-button-secondary\" : \"\"));\n        button.disabled =\n        /*disabled*/\n        ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML =\n        /*text*/\n        ctx[5];\n\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function(\n            /*action*/\n            ctx[0]))\n              /*action*/\n              ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref7) {\n        var _ref8 = _slicedToArray(_ref7, 1),\n            dirty = _ref8[0];\n\n        ctx = new_ctx;\n        if (dirty &\n        /*text*/\n        32) button.innerHTML =\n        /*text*/\n        ctx[5];\n\n        if (dirty &\n        /*label*/\n        8 && button_aria_label_value !== (button_aria_label_value =\n        /*label*/\n        ctx[3] ?\n        /*label*/\n        ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n\n        if (dirty &\n        /*classes, secondary*/\n        18 && button_class_value !== (button_class_value = \"\".concat(\n        /*classes*/\n        ctx[1] || \"\", \" shepherd-button \").concat(\n        /*secondary*/\n        ctx[4] ? \"shepherd-button-secondary\" : \"\"))) {\n          attr(button, \"class\", button_class_value);\n        }\n\n        if (dirty &\n        /*disabled*/\n        4) {\n          button.disabled =\n          /*disabled*/\n          ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n        step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n\n    function getDisabled(disabled) {\n      if (isFunction(disabled)) {\n        return disabled = disabled.call(step);\n      }\n\n      return disabled;\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"config\" in $$props) $$invalidate(6, config = $$props.config);\n      if (\"step\" in $$props) $$invalidate(7, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getDisabled(config.disabled) : false);\n          $$invalidate(3, label = config.label);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text);\n        }\n      }\n    };\n\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n\n    var _super = _createSuper(Shepherd_button);\n\n    function Shepherd_button(options) {\n      var _this3;\n\n      _classCallCheck(this, Shepherd_button);\n\n      _this3 = _super.call(this);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n\n    return Shepherd_button;\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.37.0 */\n\n\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (24:4) {#if buttons}\n\n\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value =\n    /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n\n    return {\n      c: function c() {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          each_blocks[_i3].c();\n        }\n\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {\n          each_blocks[_i4].m(target, anchor);\n        }\n\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty &\n        /*buttons, step*/\n        3) {\n          each_value =\n          /*buttons*/\n          ctx[1];\n\n          var _i5;\n\n          for (_i5 = 0; _i5 < each_value.length; _i5 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i5);\n\n            if (each_blocks[_i5]) {\n              each_blocks[_i5].p(child_ctx, dirty);\n\n              transition_in(each_blocks[_i5], 1);\n            } else {\n              each_blocks[_i5] = create_each_block(child_ctx);\n\n              each_blocks[_i5].c();\n\n              transition_in(each_blocks[_i5], 1);\n\n              each_blocks[_i5].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n\n          group_outros();\n\n          for (_i5 = each_value.length; _i5 < each_blocks.length; _i5 += 1) {\n            out(_i5);\n          }\n\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n\n        for (var _i6 = 0; _i6 < each_value.length; _i6 += 1) {\n          transition_in(each_blocks[_i6]);\n        }\n\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n\n        for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {\n          transition_out(each_blocks[_i7]);\n        }\n\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (25:8) {#each buttons as config}\n\n\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config:\n        /*config*/\n        ctx[2],\n        step:\n        /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty &\n        /*buttons*/\n        2) shepherdbutton_changes.config =\n        /*config*/\n        ctx[2];\n        if (dirty &\n        /*step*/\n        1) shepherdbutton_changes.step =\n        /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block =\n    /*buttons*/\n    ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref9) {\n        var _ref10 = _slicedToArray(_ref9, 1),\n            dirty = _ref10[0];\n\n        if (\n        /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n\n            if (dirty &\n            /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n\n    $$self.$$set = function ($$props) {\n      if (\"step\" in $$props) $$invalidate(0, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n\n    return [step, buttons];\n  }\n\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n\n    var _super2 = _createSuper(Shepherd_footer);\n\n    function Shepherd_footer(options) {\n      var _this4;\n\n      _classCallCheck(this, Shepherd_footer);\n\n      _this4 = _super2.call(this);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n\n    return Shepherd_footer;\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : \"Close Tour\");\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n\n        if (!mounted) {\n          dispose = listen(button, \"click\",\n          /*handleCancelClick*/\n          ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref11) {\n        var _ref12 = _slicedToArray(_ref11, 1),\n            dirty = _ref12[0];\n\n        if (dirty &\n        /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : \"Close Tour\")) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n        step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n\n    $$self.$$set = function ($$props) {\n      if (\"cancelIcon\" in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [cancelIcon, handleCancelClick, step];\n  }\n\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n\n      _classCallCheck(this, Shepherd_cancel_icon);\n\n      _this5 = _super3.call(this);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n\n    return Shepherd_cancel_icon;\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\",\n        /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref13) {\n        var _ref14 = _slicedToArray(_ref13, 1),\n            dirty = _ref14[0];\n\n        if (dirty &\n        /*labelId*/\n        2) {\n          attr(h3, \"id\",\n          /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        element = $$props.element,\n        title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"labelId\" in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"title\" in $$props) $$invalidate(2, title = $$props.title);\n    };\n\n    return [element, labelId, title, h3_binding];\n  }\n\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n\n    var _super4 = _createSuper(Shepherd_title);\n\n    function Shepherd_title(options) {\n      var _this6;\n\n      _classCallCheck(this, Shepherd_title);\n\n      _this6 = _super4.call(this);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n\n    return Shepherd_title;\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.37.0 */\n\n\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[0],\n        title:\n        /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty &\n        /*labelId*/\n        1) shepherdtitle_changes.labelId =\n        /*labelId*/\n        ctx[0];\n        if (dirty &\n        /*title*/\n        4) shepherdtitle_changes.title =\n        /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (39:4) {#if cancelIcon && cancelIcon.enabled}\n\n\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon:\n        /*cancelIcon*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty &\n        /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon =\n        /*cancelIcon*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        2) shepherdcancelicon_changes.step =\n        /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 =\n    /*title*/\n    ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 =\n    /*cancelIcon*/\n    ctx[3] &&\n    /*cancelIcon*/\n    ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref15) {\n        var _ref16 = _slicedToArray(_ref15, 1),\n            dirty = _ref16[0];\n\n        if (\n        /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (\n        /*cancelIcon*/\n        ctx[3] &&\n        /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        step = $$props.step;\n    var title, cancelIcon;\n\n    $$self.$$set = function ($$props) {\n      if (\"labelId\" in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if (\"step\" in $$props) $$invalidate(1, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n\n    return [labelId, step, title, cancelIcon];\n  }\n\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n\n    var _super5 = _createSuper(Shepherd_header);\n\n    function Shepherd_header(options) {\n      var _this7;\n\n      _classCallCheck(this, Shepherd_header);\n\n      _this7 = _super5.call(this);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n\n    return Shepherd_header;\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\",\n        /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref17) {\n        var _ref18 = _slicedToArray(_ref17, 1),\n            dirty = _ref18[0];\n\n        if (dirty &\n        /*descriptionId*/\n        2) {\n          attr(div, \"id\",\n          /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        element = $$props.element,\n        step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"descriptionId\" in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [element, descriptionId, step, div_binding];\n  }\n\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n\n    var _super6 = _createSuper(Shepherd_text);\n\n    function Shepherd_text(options) {\n      var _this8;\n\n      _classCallCheck(this, Shepherd_text);\n\n      _this8 = _super6.call(this);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n\n    return Shepherd_text;\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.37.0 */\n\n\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[1],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty &\n        /*labelId*/\n        2) shepherdheader_changes.labelId =\n        /*labelId*/\n        ctx[1];\n        if (dirty &\n        /*step*/\n        4) shepherdheader_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (28:2) {#if !isUndefined(step.options.text)}\n\n\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[0],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        1) shepherdtext_changes.descriptionId =\n        /*descriptionId*/\n        ctx[0];\n        if (dirty &\n        /*step*/\n        4) shepherdtext_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty &\n        /*step*/\n        4) shepherdfooter_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined(\n    /*step*/\n    ctx[2].options.title) ||\n    /*step*/\n    ctx[2].options.cancelIcon &&\n    /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined(\n    /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray(\n    /*step*/\n    ctx[2].options.buttons) &&\n    /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref19) {\n        var _ref20 = _slicedToArray(_ref19, 1),\n            dirty = _ref20[0];\n\n        if (dirty &\n        /*step*/\n        4) show_if_2 = !isUndefined(\n        /*step*/\n        ctx[2].options.title) ||\n        /*step*/\n        ctx[2].options.cancelIcon &&\n        /*step*/\n        ctx[2].options.cancelIcon.enabled;\n\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if_1 = !isUndefined(\n        /*step*/\n        ctx[2].options.text);\n\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if = Array.isArray(\n        /*step*/\n        ctx[2].options.buttons) &&\n        /*step*/\n        ctx[2].options.buttons.length;\n\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        labelId = $$props.labelId,\n        step = $$props.step;\n\n    $$self.$$set = function ($$props) {\n      if (\"descriptionId\" in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if (\"labelId\" in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if (\"step\" in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [descriptionId, labelId, step];\n  }\n\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n\n    var _super7 = _createSuper(Shepherd_content);\n\n    function Shepherd_content(options) {\n      var _this9;\n\n      _classCallCheck(this, Shepherd_content);\n\n      _this9 = _super7.call(this);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n\n    return Shepherd_content;\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.37.0 */\n\n\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block =\n    /*step*/\n    ctx[4].options.arrow &&\n    /*step*/\n    ctx[4].options.attachTo &&\n    /*step*/\n    ctx[4].options.attachTo.element &&\n    /*step*/\n    ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[2],\n        labelId:\n        /*labelId*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined(\n      /*step*/\n      ctx[4].options.text) ?\n      /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value =\n      /*step*/\n      ctx[4].options.title ?\n      /*labelId*/\n      ctx[3] : null\n    },\n    /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[13](div);\n        current = true;\n\n        if (!mounted) {\n          dispose = listen(div, \"keydown\",\n          /*handleKeyDown*/\n          ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref21) {\n        var _ref22 = _slicedToArray(_ref21, 1),\n            dirty = _ref22[0];\n\n        if (\n        /*step*/\n        ctx[4].options.arrow &&\n        /*step*/\n        ctx[4].options.attachTo &&\n        /*step*/\n        ctx[4].options.attachTo.element &&\n        /*step*/\n        ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n\n        var shepherdcontent_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId =\n        /*descriptionId*/\n        ctx[2];\n        if (dirty &\n        /*labelId*/\n        8) shepherdcontent_changes.labelId =\n        /*labelId*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        16) shepherdcontent_changes.step =\n        /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty &\n        /*step, descriptionId*/\n        20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined(\n        /*step*/\n        ctx[4].options.text) ?\n        /*descriptionId*/\n        ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty &\n        /*step, labelId*/\n        24 && div_aria_labelledby_value !== (div_aria_labelledby_value =\n        /*step*/\n        ctx[4].options.title ?\n        /*labelId*/\n        ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty &\n        /*dataStepId*/\n        2 &&\n        /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n\n  function getClassesArray(classes) {\n    return classes.split(\" \").filter(function (className) {\n      return !!className.length;\n    });\n  }\n\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n        element = $$props.element,\n        descriptionId = $$props.descriptionId,\n        firstFocusableElement = $$props.firstFocusableElement,\n        focusableElements = $$props.focusableElements,\n        labelId = $$props.labelId,\n        lastFocusableElement = $$props.lastFocusableElement,\n        step = $$props.step,\n        dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\\\"0\\\"]\"));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n\n        if (oldClasses.length) {\n          var _element$classList;\n\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n\n        if (newClasses.length) {\n          var _element$classList2;\n\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n          tour = _step.tour;\n\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains(\"shepherd-element\")) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n\n          break;\n\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n\n          break;\n\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n\n          break;\n      }\n    };\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"classPrefix\" in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"descriptionId\" in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if (\"firstFocusableElement\" in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if (\"focusableElements\" in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if (\"labelId\" in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if (\"lastFocusableElement\" in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if (\"step\" in $$props) $$invalidate(4, step = $$props.step);\n      if (\"dataStepId\" in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n\n    var _super8 = _createSuper(Shepherd_element);\n\n    function Shepherd_element(options) {\n      var _this10;\n\n      _classCallCheck(this, Shepherd_element);\n\n      _this10 = _super8.call(this);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n\n    return Shepherd_element;\n  }(SvelteComponent);\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n\n            original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n\n    var _super9 = _createSuper(Step);\n\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an attachTo the element will appear in the middle of the screen.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * @param {HTMLElement|string} options.attachTo.element An element selector string or a DOM element.\n     * @param {string} options.attachTo.on The optional direction to place the Popper tooltip relative to the element.\n     *   - Possible string values: 'auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour) {\n      var _this11;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Step);\n\n      _this11 = _super9.call(this, tour, options);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n      autoBind(_assertThisInitialized(_this11));\n\n      _this11._setOptions(options);\n\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n\n\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n       * Triggers `destroy` event\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n\n        if (isHTMLElement$1(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n\n        this._updateStepTargetOnHide();\n\n        this.trigger('destroy');\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Hide the step\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n\n        if (this.el) {\n          this.el.hidden = true;\n        }\n\n        this._updateStepTargetOnHide();\n\n        this.trigger('hide');\n      }\n      /**\n       * Checks if the step should be centered or not\n       * @return {boolean} True if the step is centered\n       */\n\n    }, {\n      key: \"isCentered\",\n      value: function isCentered() {\n        var attachToOptions = parseAttachTo(this);\n        return !attachToOptions.element || !attachToOptions.on;\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this12._show();\n            });\n          }\n        }\n\n        this._show();\n      }\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _parseAttachTo = parseAttachTo(this),\n            element = _parseAttachTo.element;\n\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions() {\n        var _this13 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options);\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n      /**\n       * Create the element and set up the Popper instance\n       * @private\n       */\n\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n\n        this.el = this._createTooltipContent();\n\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n\n        setupTooltip(this);\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a Popper instance for the tooltip, then triggers `show`.\n       * @private\n       */\n\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n\n        this.trigger('before-show');\n\n        this._setupElements();\n\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n\n        this.tour.modal.setupForStep(this);\n\n        this._styleTargetElementForStep(this);\n\n        this.el.hidden = false; // start scrolling to target before showing the step\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n\n        if (!targetElement) {\n          return;\n        }\n\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n\n\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n\n\n  function makeOverlayPath(_ref23) {\n    var width = _ref23.width,\n        height = _ref23.height,\n        _ref23$x = _ref23.x,\n        x = _ref23$x === void 0 ? 0 : _ref23$x,\n        _ref23$y = _ref23.y,\n        y = _ref23$y === void 0 ? 0 : _ref23$y,\n        _ref23$r = _ref23.r,\n        r = _ref23$r === void 0 ? 0 : _ref23$r;\n    var _window = window,\n        w = _window.innerWidth,\n        h = _window.innerHeight;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + r, \",\").concat(y, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \",\").concat(r, \"V\").concat(height + y - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \",\").concat(r, \"H\").concat(width + x - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \"-\").concat(r, \"V\").concat(y + r, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \"-\").concat(r, \"Z\");\n  }\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.37.0 */\n\n\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\",\n        /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat(\n        /*modalIsVisible*/\n        ctx[1] ? \"shepherd-modal-is-visible\" : \"\", \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[11](svg);\n\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\",\n          /*_preventModalOverlayTouch*/\n          ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref24) {\n        var _ref25 = _slicedToArray(_ref24, 1),\n            dirty = _ref25[0];\n\n        if (dirty &\n        /*pathDefinition*/\n        4) {\n          attr(path, \"d\",\n          /*pathDefinition*/\n          ctx[2]);\n        }\n\n        if (dirty &\n        /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = \"\".concat(\n        /*modalIsVisible*/\n        ctx[1] ? \"shepherd-modal-is-visible\" : \"\", \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== \"hidden\" && overflowY !== \"visible\";\n\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n        openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n\n    function positionModal() {\n      var modalOverlayOpeningPadding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var modalOverlayOpeningRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scrollParent = arguments.length > 2 ? arguments[2] : undefined;\n      var targetElement = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n            y = _getVisibleHeight2.y,\n            height = _getVisibleHeight2.height;\n\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n            x = _targetElement$getBou.x,\n            width = _targetElement$getBou.width,\n            _left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || _left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n\n        show();\n      } else {\n        hide();\n      }\n    }\n\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener(\"touchmove\", _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n\n      window.removeEventListener(\"touchmove\", _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n          modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n          modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n\n      var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n\n      rafLoop();\n\n      _addStepEventListeners();\n    }\n\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? \"unshift\" : \"push\"](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if (\"element\" in $$props) $$invalidate(0, element = $$props.element);\n      if (\"openingProperties\" in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n\n    var _super10 = _createSuper(Shepherd_modal);\n\n    function Shepherd_modal(options) {\n      var _this15;\n\n      _classCallCheck(this, Shepherd_modal);\n\n      _this15 = _super10.call(this);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n\n    return Shepherd_modal;\n  }(SvelteComponent);\n\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n\n    var _super11 = _createSuper(Tour);\n\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour() {\n      var _this16;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, Tour);\n\n      _this16 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n\n      _this16.addSteps(_this16.options.steps); // Pass these events onto the global Shepherd object\n\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n\n      _this16._setTourID();\n\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n\n\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n\n        return step;\n      }\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n\n        return this;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n\n          if (stopTour) {\n            this._done('cancel');\n          }\n        } else {\n          this._done('cancel');\n        }\n      }\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n\n            step.destroy();\n\n            _this18.steps.splice(i, 1);\n\n            return true;\n          }\n        });\n\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n\n        if (step) {\n          this._updateStateBeforeShow();\n\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start'); // Save the focused element before the tour opens\n\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n\n        this._setupModal();\n\n        this._setupActiveTour();\n\n        this.next();\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n\n        if (this.modal) {\n          this.modal.hide();\n        }\n\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        } // Focus the element that was focused before the tour started\n\n\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        var nextIndex = forward ? index + 1 : index - 1;\n        this.show(nextIndex, forward);\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n\n    return Tour;\n  }(Evented);\n\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz81YWQxIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvdXRpbHMvdHlwZS1jaGVjay5qcz8xZmQzIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvZXZlbnRlZC5qcz85NzNkIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvdXRpbHMvYXV0by1iaW5kLmpzPzdiMTYiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy91dGlscy9iaW5kLmpzP2E1MTUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NDY5NyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/OTA2MCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzPzlhOTQiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/N2NmOCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/MTJlYiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzPzE1N2QiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9kZDE0Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzPzc4MDMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzPzU4MTAiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/MDkwOCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanM/MzdkNCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzPzM4NDgiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/ZTA4OSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzPzU4MmEiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzPzVkMGIiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcz8zYjhjIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcz9kMDkzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcz9kMDdmIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz84MGY1Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz81NDExIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcz9kMTMwIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzYzOTEiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzPzc5MzUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanM/YTAwNiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcz9mODFlIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanM/OGE3MCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcz82NmQzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/ZDdmZSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzPzMzMWUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzPzc4NjMiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz9hMzJhIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcz82ZjU5Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanM/OWMzOSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzP2QxNmQiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzP2MwMWYiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanM/NGU3NSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9iNTM0Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzJlYTEiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanM/ZGI0OCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcz9hYjk3Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/YzM2OSIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcz81ODAxIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanM/ZDhjNyIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzP2Y5OGUiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzP2I3ZTYiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanM/NjZjZiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9kZDJhIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzP2NmYWIiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanM/YjgwYiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz9iMDY5Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcz9hOTAwIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcz81MTVlIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvdXRpbHMvcG9wcGVyLW9wdGlvbnMuanM/YzY5YiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL3V0aWxzL2dlbmVyYWwuanM/YjQyZCIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanM/MDRmNyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtYnV0dG9uLnN2ZWx0ZT83OGM1Iiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1mb290ZXIuc3ZlbHRlP2FmNDciLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZT83OWMxIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10aXRsZS5zdmVsdGU/Y2FjMiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtaGVhZGVyLnN2ZWx0ZT8yZjI3Iiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10ZXh0LnN2ZWx0ZT9hY2VmIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1jb250ZW50LnN2ZWx0ZT9mMDdlIiwid2VicGFjazovLy8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1lbGVtZW50LnN2ZWx0ZT9iNTg2Iiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzP2U2YzgiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy9zdGVwLmpzP2FkOGQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy91dGlscy9jbGVhbnVwLmpzPzZkY2EiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy91dGlscy9vdmVybGF5LXBhdGguanM/Y2Q1MyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtbW9kYWwuc3ZlbHRlP2Y1NGIiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy90b3VyLmpzPzM5NTEiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9qcy9zaGVwaGVyZC5qcz81MTQ0Il0sIm5hbWVzIjpbImlzTWVyZ2VhYmxlT2JqZWN0IiwiaXNOb25OdWxsT2JqZWN0IiwiaXNTcGVjaWFsIiwic3RyaW5nVmFsdWUiLCJPYmplY3QiLCJpc1JlYWN0RWxlbWVudCIsImNhblVzZVN5bWJvbCIsIlN5bWJvbCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsInZhbHVlIiwiQXJyYXkiLCJvcHRpb25zIiwiZGVlcG1lcmdlIiwiZW1wdHlUYXJnZXQiLCJjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCIsImN1c3RvbU1lcmdlIiwidGFyZ2V0IiwiZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5IiwiZGVzdGluYXRpb24iLCJnZXRLZXlzIiwicHJvcGVydHlJc1Vuc2FmZSIsInByb3BlcnR5SXNPbk9iamVjdCIsInNvdXJjZSIsImdldE1lcmdlRnVuY3Rpb24iLCJzb3VyY2VJc0FycmF5IiwidGFyZ2V0SXNBcnJheSIsInNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2giLCJtZXJnZU9iamVjdCIsImRlZXBtZXJnZV8xIiwib24iLCJvbmNlIiwiaXNVbmRlZmluZWQiLCJoYW5kbGVyIiwiY3R4Iiwib2ZmIiwiYmluZGluZyIsInRyaWdnZXIiLCJjb250ZXh0Iiwia2V5cyIsInNlbGYiLCJpIiwia2V5IiwidmFsIiwiZXZlbnQiLCJzdGVwIiwidGFyZ2V0SXNFbCIsInRhcmdldElzU2VsZWN0b3IiLCJzZWxlY3RvciIsIl9zZXR1cEFkdmFuY2VPbkhhbmRsZXIiLCJlbCIsImRvY3VtZW50IiwiY29uc29sZSIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZWxlbWVudCIsIm5vZGUiLCJvd25lckRvY3VtZW50IiwiT3duRWxlbWVudCIsImdldFdpbmRvdyIsInN0YXRlIiwiX3JlZiIsInN0eWxlIiwiYXR0cmlidXRlcyIsImlzSFRNTEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsIl9yZWYyIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJuYW1lIiwiZW5hYmxlZCIsInBoYXNlIiwiZm4iLCJlZmZlY3QiLCJyZXF1aXJlcyIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwiY2xpZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk1hdGgiLCJyb290Tm9kZSIsImNoaWxkIiwicGFyZW50IiwiaXNTaGFkb3dSb290IiwibmV4dCIsImlzRWxlbWVudCIsIndpbmRvdyIsImdldERvY3VtZW50RWxlbWVudCIsImdldENvbXB1dGVkU3R5bGUiLCJpc0ZpcmVmb3giLCJuYXZpZ2F0b3IiLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiZ2V0UGFyZW50Tm9kZSIsImNzcyIsIm9mZnNldFBhcmVudCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJpc1RhYmxlRWxlbWVudCIsImdldENvbnRhaW5pbmdCbG9jayIsIm1heCIsIm1pbiIsInJvdW5kIiwibWF0aE1heCIsIm1hdGhNaW4iLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsIm1lcmdlUGFkZGluZ09iamVjdCIsImV4cGFuZFRvSGFzaE1hcCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJiYXNlUGxhY2VtZW50IiwiZ2V0QmFzZVBsYWNlbWVudCIsImF4aXMiLCJnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQiLCJpc1ZlcnRpY2FsIiwibGVuIiwicGFkZGluZ09iamVjdCIsImFycm93UmVjdCIsImdldExheW91dFJlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsIndpdGhpbiIsImF4aXNQcm9wIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiX29wdGlvbnMkZWxlbWVudCIsImNvbnRhaW5zIiwicmVxdWlyZXNJZkV4aXN0cyIsInVuc2V0U2lkZXMiLCJ3aW4iLCJkcHIiLCJwb3BwZXJSZWN0Iiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiX3JlZjMiLCJyb3VuZE9mZnNldHNCeURQUiIsIl9yZWYzJHgiLCJfcmVmMyR5IiwiaGFzWCIsImhhc1kiLCJzaWRlWCIsInNpZGVZIiwiaGVpZ2h0UHJvcCIsIndpZHRoUHJvcCIsImNvbW1vblN0eWxlcyIsIl9PYmplY3QkYXNzaWduIiwiX09iamVjdCRhc3NpZ24yIiwiX3JlZjQiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsIm1hcFRvU3R5bGVzIiwiZGF0YSIsInBhc3NpdmUiLCJpbnN0YW5jZSIsIl9vcHRpb25zJHNjcm9sbCIsInNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxQYXJlbnQiLCJoYXNoIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImdldFdpbmRvd1Njcm9sbCIsImh0bWwiLCJ2aXN1YWxWaWV3cG9ydCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJ3aW5TY3JvbGwiLCJib2R5IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImlzU2Nyb2xsUGFyZW50IiwiZ2V0U2Nyb2xsUGFyZW50IiwibGlzdCIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwibGlzdFNjcm9sbFBhcmVudHMiLCJjbGlwcGluZ1BhcmVudCIsInJlY3RUb0NsaWVudFJlY3QiLCJnZXRWaWV3cG9ydFJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImdldERvY3VtZW50UmVjdCIsImNhbkVzY2FwZUNsaXBwaW5nIiwiY2xpcHBlckVsZW1lbnQiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiYm91bmRhcnkiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJmaXJzdENsaXBwaW5nUGFyZW50IiwiY2xpcHBpbmdSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUiLCJhY2NSZWN0IiwidmFyaWF0aW9uIiwiZ2V0VmFyaWF0aW9uIiwiY29tbW9uWCIsImNvbW1vblkiLCJtYWluQXhpcyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsInJlZmVyZW5jZUVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJnZXRDbGlwcGluZ1JlY3QiLCJyZWZlcmVuY2VDbGllbnRSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJzdHJhdGVneSIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHMiLCJvdmVyZmxvd3MiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiY2hlY2tBbHRBeGlzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiX29wdGlvbnMkZmxpcFZhcmlhdGlvIiwicHJlZmVycmVkUGxhY2VtZW50IiwiaXNCYXNlUGxhY2VtZW50IiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwiZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJkZXRlY3RPdmVyZmxvdyIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJmaXR0aW5nUGxhY2VtZW50IiwiX2kiLCJfcmV0IiwiX3NraXAiLCJwcmV2ZW50ZWRPZmZzZXRzIiwicmVmZXJlbmNlT3ZlcmZsb3ciLCJwb3BwZXJBbHRPdmVyZmxvdyIsInJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyIsImdldFNpZGVPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwiaGFzUG9wcGVyRXNjYXBlZCIsImhpZGUiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJkaXN0YW5jZUFuZFNraWRkaW5nVG9YWSIsIl9kYXRhJHN0YXRlJHBsYWNlbWVudCIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsImFsdEF4aXMiLCJnZXRBbHRBeGlzIiwidGV0aGVyT2Zmc2V0VmFsdWUiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9tYWluU2lkZSIsIl9hbHRTaWRlIiwiX29mZnNldCIsIl9taW4iLCJfbWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsImdldEhUTUxFbGVtZW50U2Nyb2xsIiwiaXNGaXhlZCIsImRvY3VtZW50RWxlbWVudCIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IiwiZ2V0Tm9kZVNjcm9sbCIsIm1hcCIsInZpc2l0ZWQiLCJyZXN1bHQiLCJtb2RpZmllcnMiLCJtb2RpZmllciIsImRlcE1vZGlmaWVyIiwic29ydCIsIm9yZGVyZWRNb2RpZmllcnMiLCJvcmRlciIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1lcmdlZCIsImV4aXN0aW5nIiwiY3VycmVudCIsIkRFRkFVTFRfT1BUSU9OUyIsIl9sZW4iLCJhcmd1bWVudHMiLCJhcmdzIiwiX2tleSIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJtb2RpZmllcnNEYXRhIiwiZWxlbWVudHMiLCJzdHlsZXMiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm9yZGVyTW9kaWZpZXJzIiwibWVyZ2VCeU5hbWUiLCJtIiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImluZGV4IiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsInVwZGF0ZSIsImRlYm91bmNlIiwiZGVzdHJveSIsIl9yZWYzJG9wdGlvbnMiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJjcmVhdGVQb3BwZXIiLCJwb3BwZXJHZW5lcmF0b3IiLCJ0cmFuc2Zvcm0iLCJjZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyIiwicG9wcGVyT3B0aW9ucyIsInNldFRpbWVvdXQiLCJpc1N0cmluZyIsInByZWZpeCIsInJldHVybk9wdHMiLCJhdHRhY2hUb09wdGlvbnMiLCJwYXJzZUF0dGFjaFRvIiwiZ2V0UG9wcGVyT3B0aW9ucyIsImNvbnRlbnQiLCJkIiwiRGF0ZSIsImMiLCJyIiwibWFrZUNlbnRlcmVkUG9wcGVyIiwiZGVmYXVsdFN0ZXBPcHRpb25zIiwiX21lcmdlTW9kaWZpZXJzIiwic3RlcE9wdGlvbnMiLCJtZXJnZWRQb3BwZXJPcHRpb25zIiwibmFtZXMiLCJtb2QiLCJmaWx0ZXJlZE1vZGlmaWVycyIsInRhciIsInNyYyIsImZucyIsImEiLCJiIiwiYW5jaG9yIiwiaXRlcmF0aW9ucyIsInRleHQiLCJkZXNjcmlwdG9ycyIsImF0dHIiLCJ0b2dnbGUiLCJjdXJyZW50X2NvbXBvbmVudCIsImdldF9jdXJyZW50X2NvbXBvbmVudCIsImRpcnR5X2NvbXBvbmVudHMiLCJiaW5kaW5nX2NhbGxiYWNrcyIsInJlbmRlcl9jYWxsYmFja3MiLCJmbHVzaF9jYWxsYmFja3MiLCJyZXNvbHZlZF9wcm9taXNlIiwidXBkYXRlX3NjaGVkdWxlZCIsImZsdXNoaW5nIiwic2Vlbl9jYWxsYmFja3MiLCJjb21wb25lbnQiLCJzZXRfY3VycmVudF9jb21wb25lbnQiLCJjYWxsYmFjayIsIiQkIiwicnVuX2FsbCIsImRpcnR5Iiwib3V0cm9pbmciLCJvdXRyb3MiLCJwIiwiYmxvY2siLCJ0b19udWxsX291dCIsImFjY291bnRlZF9mb3IiLCIkJHNjb3BlIiwibGV2ZWxzIiwibyIsIm4iLCJ1cGRhdGVzIiwiYWZ0ZXJfdXBkYXRlIiwiZnJhZ21lbnQiLCJhZGRfcmVuZGVyX2NhbGxiYWNrIiwibmV3X29uX2Rlc3Ryb3kiLCJvbl9tb3VudCIsIm9uX2Rlc3Ryb3kiLCJzY2hlZHVsZV91cGRhdGUiLCJwYXJlbnRfY29tcG9uZW50IiwicHJvcHMiLCJub3RfZXF1YWwiLCJib3VuZCIsImJsYW5rX29iamVjdCIsIm9uX2Rpc2Nvbm5lY3QiLCJiZWZvcmVfdXBkYXRlIiwiY2FsbGJhY2tzIiwic2tpcF9ib3VuZCIsInJlYWR5IiwicmVzdCIsIm1ha2VfZGlydHkiLCJjcmVhdGVfZnJhZ21lbnQiLCJub2RlcyIsImNoaWxkcmVuIiwidHJhbnNpdGlvbl9pbiIsIm1vdW50X2NvbXBvbmVudCIsImZsdXNoIiwiJGRlc3Ryb3kiLCJkZXN0cm95X2NvbXBvbmVudCIsIiRvbiIsIiRzZXQiLCJpc19lbXB0eSIsImNvbmZpZyIsImFjdGlvbiIsImNsYXNzZXMiLCJkaXNhYmxlZCIsImxhYmVsIiwic2Vjb25kYXJ5IiwiZ2V0RGlzYWJsZWQiLCJpc0Z1bmN0aW9uIiwiJCIsImxlbmd0aCIsImJ1dHRvbnMiLCJjYW5jZWxJY29uIiwiaGFuZGxlQ2FuY2VsQ2xpY2siLCJlIiwibGFiZWxJZCIsInRpdGxlIiwiYWZ0ZXJVcGRhdGUiLCJkZXNjcmlwdGlvbklkIiwiS0VZX1RBQiIsIktFWV9FU0MiLCJMRUZUX0FSUk9XIiwiUklHSFRfQVJST1ciLCJnZXRDbGFzc2VzQXJyYXkiLCJjbGFzc05hbWUiLCJjbGFzc1ByZWZpeCIsImZpcnN0Rm9jdXNhYmxlRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwibGFzdEZvY3VzYWJsZUVsZW1lbnQiLCJkYXRhU3RlcElkIiwiaGFzQ2FuY2VsSWNvbiIsImhhc1RpdGxlIiwiZ2V0RWxlbWVudCIsIm9uTW91bnQiLCJpZCIsInVwZGF0ZUR5bmFtaWNDbGFzc2VzIiwicmVtb3ZlQ2xhc3NlcyIsImFkZENsYXNzZXMiLCJvbGRDbGFzc2VzIiwibmV3Q2xhc3NlcyIsImhhbmRsZUtleURvd24iLCJ0b3VyIiwia2V5Q29kZSIsInNoaWZ0S2V5IiwiZXhpdE9uRXNjIiwia2V5Ym9hcmROYXZpZ2F0aW9uIiwidyIsIkVsZW1lbnQiLCJTQ1JPTExfVElNRSIsIm9yaWdpbmFsIiwic2Nyb2xsQnkiLCJlbGVtZW50U2Nyb2xsIiwic2Nyb2xsSW50b1ZpZXciLCJub3ciLCJ1c2VyQWdlbnRQYXR0ZXJucyIsIlJPVU5ESU5HX1RPTEVSQU5DRSIsImlzTWljcm9zb2Z0QnJvd3NlciIsImZpcnN0QXJnIiwib3ZlcmZsb3dWYWx1ZSIsImlzU2Nyb2xsYWJsZVkiLCJoYXNTY3JvbGxhYmxlU3BhY2UiLCJjYW5PdmVyZmxvdyIsImlzU2Nyb2xsYWJsZVgiLCJpc1Njcm9sbGFibGUiLCJ0aW1lIiwiZWxhcHNlZCIsImVhc2UiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwic3RhcnRUaW1lIiwic2Nyb2xsYWJsZSIsInN0YXJ0WCIsInN0YXJ0WSIsIm1ldGhvZCIsInNob3VsZEJhaWxPdXQiLCJzbW9vdGhTY3JvbGwiLCJiZWhhdmlvciIsInNjcm9sbGFibGVQYXJlbnQiLCJmaW5kU2Nyb2xsYWJsZVBhcmVudCIsInBhcmVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJtb2R1bGUiLCJwb2x5ZmlsbCIsInNtb290aHNjcm9sbCIsImNvbnN0cnVjdG9yIiwibm9ybWFsaXplUHJlZml4IiwiYXV0b0JpbmQiLCJjYW5jZWwiLCJjb21wbGV0ZSIsImdldFRvdXIiLCJpc0NlbnRlcmVkIiwiaXNPcGVuIiwiQm9vbGVhbiIsInNob3ciLCJiZWZvcmVTaG93UHJvbWlzZSIsInVwZGF0ZVN0ZXBPcHRpb25zIiwiZ2V0VGFyZ2V0IiwiX2NyZWF0ZVRvb2x0aXBDb250ZW50IiwiX3Njcm9sbFRvIiwiX2dldENsYXNzT3B0aW9ucyIsInN0ZXBDbGFzc2VzIiwiZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3NlcyIsImFsbENsYXNzZXMiLCJ1bmlxQ2xhc3NlcyIsIl9zZXRPcHRpb25zIiwidG91ck9wdGlvbnMiLCJtZXJnZSIsIndoZW4iLCJ1dWlkIiwiX3NldHVwRWxlbWVudHMiLCJiaW5kQWR2YW5jZSIsInNldHVwVG9vbHRpcCIsIl9zaG93IiwiX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAiLCJ0YXJnZXRFbGVtZW50IiwiX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUiLCJzdGVwcyIsImlubmVyV2lkdGgiLCJoIiwiaW5uZXJIZWlnaHQiLCJfZ2V0U2Nyb2xsUGFyZW50IiwiaXNIdG1sRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwiX2dldFZpc2libGVIZWlnaHQiLCJlbGVtZW50UmVjdCIsInNjcm9sbFJlY3QiLCJzY3JvbGxCb3R0b20iLCJvcGVuaW5nUHJvcGVydGllcyIsIm1vZGFsSXNWaXNpYmxlIiwicmFmSWQiLCJ1bmRlZmluZWQiLCJwYXRoRGVmaW5pdGlvbiIsImNsb3NlTW9kYWxPcGVuaW5nIiwiX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMiLCJwb3NpdGlvbk1vZGFsIiwibW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmciLCJtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIiwic2V0dXBGb3JTdGVwIiwidXNlTW9kYWxPdmVybGF5IiwiX3N0eWxlRm9yU3RlcCIsIl9wcmV2ZW50TW9kYWxCb2R5VG91Y2giLCJfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNoIiwiX2FkZFN0ZXBFdmVudExpc3RlbmVycyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmFmTG9vcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1ha2VPdmVybGF5UGF0aCIsIlNoZXBoZXJkIiwiZGVmYXVsdFRvdXJPcHRpb25zIiwiZXZlbnRzIiwib3B0cyIsImFkZFN0ZXAiLCJhZGRTdGVwcyIsImJhY2siLCJjYW5jZWxNZXNzYWdlIiwic3RvcFRvdXIiLCJnZXRCeUlkIiwiZ2V0Q3VycmVudFN0ZXAiLCJjdXJyZW50U3RlcCIsImlzQWN0aXZlIiwicmVtb3ZlU3RlcCIsImZvcndhcmQiLCJzaG91bGRTa2lwU3RlcCIsInByZXZpb3VzIiwiX2RvbmUiLCJjbGVhbnVwU3RlcHMiLCJtb2RhbENvbnRhaW5lciIsIl9zZXR1cEFjdGl2ZVRvdXIiLCJfc2V0dXBNb2RhbCIsIl9za2lwU3RlcCIsIm5leHRJbmRleCIsIl91cGRhdGVTdGF0ZUJlZm9yZVNob3ciLCJfc2V0VG91cklEIiwidG91ck5hbWUiLCJUb3VyIiwiU3RlcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsTUFBSUEsaUJBQWlCLEdBQUcsa0NBQWtDO0FBQ3pELFdBQU9DLGVBQWUsQ0FBZkEsS0FBZSxDQUFmQSxJQUNILENBQUNDLFNBQVMsQ0FEZCxLQUNjLENBRGQ7QUFERDs7QUFLQSxrQ0FBZ0M7QUFDL0IsV0FBTyxDQUFDLENBQUQsU0FBVyxtQkFBbEI7QUFDQTs7QUFFRCw0QkFBMEI7QUFDekIsUUFBSUMsV0FBVyxHQUFHQyxNQUFNLENBQU5BLHdCQUFsQixLQUFrQkEsQ0FBbEI7QUFFQSxXQUFPRCxXQUFXLEtBQVhBLHFCQUNIQSxXQUFXLEtBRFJBLG1CQUVIRSxjQUFjLENBRmxCLEtBRWtCLENBRmxCO0FBR0EsRyxDQUFBOzs7QUFHRCxNQUFJQyxZQUFZLEdBQUcs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QTtBQUNBOzs7O2FBQ0U2UixtQkFBUyxJQUFUQSxFQUFTLE9BQVRBLEVBQXlCO0FBQ3ZCLFlBQU1oUixLQUFLLEdBQUcsbUJBQWQsSUFBYyxDQUFkO0FBQ0EsWUFBTWlSLFNBQVMsR0FBR1QsT0FBTyxHQUFHeFEsS0FBSyxHQUFSLElBQWVBLEtBQUssR0FBN0M7QUFDQTtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OzthQUNFa1Isa0NBQXlCO0FBQ3ZCLFlBQUksS0FBSixhQUFzQjtBQUNwQjtBQUNEOztBQUVELFlBQUksQ0FBQyxLQUFMLFFBQUssRUFBTCxFQUFzQjtBQUNwQjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7OzthQUNFQyxzQkFBYTtBQUNYLFlBQU1DLFFBQVEsR0FBRyx5QkFBakI7QUFFQSw0QkFBYUEsUUFBYixlQUEwQmxFLElBQTFCO0FBQ0Q7Ozs7SUE5VkksTzs7QUNYUHBsQixRQUFNLENBQU5BLGlCQUF3QjtBQUFFdXBCLFFBQUYsRUFBRUEsSUFBRjtBQUFRQztBQUFSLEdBQXhCeHBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NoZXBoZXJkLmpzL2Rpc3QvanMvc2hlcGhlcmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiB0YXJnZXQucHJvcGVydHlJc0VudW1lcmFibGUoc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEVsZW1lbnRgLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYW4gRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgSFRNTEVsZW1lbnRgLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYW4gSFRNTEVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrJztcblxuZXhwb3J0IGNsYXNzIEV2ZW50ZWQge1xuICBvbihldmVudCwgaGFuZGxlciwgY3R4LCBvbmNlID0gZmFsc2UpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3NbZXZlbnRdKSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5iaW5kaW5nc1tldmVudF0ucHVzaCh7IGhhbmRsZXIsIGN0eCwgb25jZSB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25jZShldmVudCwgaGFuZGxlciwgY3R4KSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGhhbmRsZXIsIGN0eCwgdHJ1ZSk7XG4gIH1cblxuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykgfHxcbiAgICAgIGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3NbZXZlbnRdKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKSB7XG4gICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1tldmVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLmZvckVhY2goKGJpbmRpbmcsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChiaW5kaW5nLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyaWdnZXIoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3MpICYmIHRoaXMuYmluZGluZ3NbZXZlbnRdKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5mb3JFYWNoKChiaW5kaW5nLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN0eCwgaGFuZGxlciwgb25jZSB9ID0gYmluZGluZztcblxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3R4IHx8IHRoaXM7XG5cbiAgICAgICAgaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcblxuICAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59IiwiLyoqXG4gKiBCaW5kcyBhbGwgdGhlIG1ldGhvZHMgb24gYSBKUyBDbGFzcyB0byB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYXV0by1iaW5kXG4gKiBAcGFyYW0ge29iamVjdH0gc2VsZiBUaGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b0JpbmQoc2VsZikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2VsZi5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbCA9IHNlbGZba2V5XTtcbiAgICBpZiAoa2V5ICE9PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGZba2V5XSA9IHZhbC5iaW5kKHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3R5cGUtY2hlY2snO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBhZHZhbmNlIHRoZSB0b3VyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2V0dXBBZHZhbmNlT25IYW5kbGVyKHNlbGVjdG9yLCBzdGVwKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoc3RlcC5pc09wZW4oKSkge1xuICAgICAgY29uc3QgdGFyZ2V0SXNFbCA9IHN0ZXAuZWwgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gc3RlcC5lbDtcbiAgICAgIGNvbnN0IHRhcmdldElzU2VsZWN0b3IgPSAhaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQubWF0Y2hlcyhzZWxlY3Rvcik7XG5cbiAgICAgIGlmICh0YXJnZXRJc1NlbGVjdG9yIHx8IHRhcmdldElzRWwpIHtcbiAgICAgICAgc3RlcC50b3VyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQmluZCB0aGUgZXZlbnQgaGFuZGxlciBmb3IgYWR2YW5jZU9uXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBZHZhbmNlKHN0ZXApIHtcbiAgLy8gQW4gZW1wdHkgc2VsZWN0b3IgbWF0Y2hlcyB0aGUgc3RlcCBlbGVtZW50XG4gIGNvbnN0IHsgZXZlbnQsIHNlbGVjdG9yIH0gPSBzdGVwLm9wdGlvbnMuYWR2YW5jZU9uIHx8IHt9O1xuICBpZiAoZXZlbnQpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gX3NldHVwQWR2YW5jZU9uSGFuZGxlcihzZWxlY3Rvciwgc3RlcCk7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBhbHNvIGJpbmQvdW5iaW5kIG9uIHNob3cvaGlkZVxuICAgIGxldCBlbDtcbiAgICB0cnkge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmICFlbCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYE5vIGVsZW1lbnQgd2FzIGZvdW5kIGZvciB0aGUgc2VsZWN0b3Igc3VwcGxpZWQgdG8gYWR2YW5jZU9uOiAke3NlbGVjdG9yfWApO1xuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgc3RlcC5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICBzdGVwLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcignYWR2YW5jZU9uIHdhcyBkZWZpbmVkLCBidXQgbm8gZXZlbnQgbmFtZSB3YXMgcGFzc2VkLicpO1xuICB9XG59XG4iLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgeDogcmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjsgLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufSIsImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpICE9PSAtMTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59IiwiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHdpdGhpbiBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNIVE1MRWxlbWVudChhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZChyb3VuZCh4ICogZHByKSAvIGRwcikgfHwgMCxcbiAgICB5OiByb3VuZChyb3VuZCh5ICogZHByKSAvIGRwcikgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzO1xuXG4gIHZhciBfcmVmMyA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKG9mZnNldHMpIDogdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyhvZmZzZXRzKSA6IG9mZnNldHMsXG4gICAgICBfcmVmMyR4ID0gX3JlZjMueCxcbiAgICAgIHggPSBfcmVmMyR4ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeCxcbiAgICAgIF9yZWYzJHkgPSBfcmVmMy55LFxuICAgICAgeSA9IF9yZWYzJHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmMyR5O1xuXG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgIHkgLT0gb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0KSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgeCAtPSBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXSAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8IDIgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjQuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjQub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciB0cmFuc2l0aW9uUHJvcGVydHkgPSBnZXRDb21wdXRlZFN0eWxlKHN0YXRlLmVsZW1lbnRzLnBvcHBlcikudHJhbnNpdGlvblByb3BlcnR5IHx8ICcnO1xuXG4gICAgaWYgKGFkYXB0aXZlICYmIFsndHJhbnNmb3JtJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLnNvbWUoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvblByb3BlcnR5LmluZGV4T2YocHJvcGVydHkpID49IDA7XG4gICAgfSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogRGV0ZWN0ZWQgQ1NTIHRyYW5zaXRpb25zIG9uIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nJywgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsICdcXG5cXG4nLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgJ2ZvciBzbW9vdGggdHJhbnNpdGlvbnMsIG9yIHJlbW92ZSB0aGVzZSBwcm9wZXJ0aWVzIGZyb20gdGhlIENTUycsICd0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmcnLCAnb3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLicsICdcXG5cXG4nLCAnV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyJywgJ2VsZW1lbnQgdGhhdCBjYW4gaGF2ZSBhbnkgQ1NTIHByb3BlcnR5IHRyYW5zaXRpb25lZCBmb3IgYW5pbWF0aW9ucy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDsgLy8gTkI6IFRoaXMgaXNuJ3Qgc3VwcG9ydGVkIG9uIGlPUyA8PSAxMi4gSWYgdGhlIGtleWJvYXJkIGlzIG9wZW4sIHRoZSBwb3BwZXJcbiAgLy8gY2FuIGJlIG9ic2N1cmVkIHVuZGVybmVhdGggaXQuXG4gIC8vIEFsc28sIGBodG1sLmNsaWVudEhlaWdodGAgYWRkcyB0aGUgYm90dG9tIGJhciBoZWlnaHQgaW4gU2FmYXJpIGlPUywgZXZlblxuICAvLyBpZiBpdCBpc24ndCBvcGVuLCBzbyBpZiB0aGlzIGlzbid0IGF2YWlsYWJsZSwgdGhlIHBvcHBlciB3aWxsIGJlIGRldGVjdGVkXG4gIC8vIHRvIG92ZXJmbG93IHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiB0b28gZWFybHkuXG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7IC8vIFVzZXMgTGF5b3V0IFZpZXdwb3J0IChsaWtlIENocm9tZTsgU2FmYXJpIGRvZXMgbm90IGN1cnJlbnRseSlcbiAgICAvLyBJbiBDaHJvbWUsIGl0IHJldHVybnMgYSB2YWx1ZSB2ZXJ5IGNsb3NlIHRvIDAgKCsvLSkgYnV0IGNvbnRhaW5zIHJvdW5kaW5nXG4gICAgLy8gZXJyb3JzIGR1ZSB0byBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHByZWNpc2lvbi5cbiAgICAvLyBTYWZhcmkgcmV0dXJucyBhIG51bWJlciA8PSAwLCB1c3VhbGx5IDwgLTEgd2hlbiBwaW5jaC16b29tZWRcbiAgICAvLyBGZWF0dXJlIGRldGVjdGlvbiBmYWlscyBpbiBtb2JpbGUgZW11bGF0aW9uIG1vZGUgaW4gQ2hyb21lLlxuICAgIC8vIE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdmlzdWFsVmlld3BvcnQuc2NhbGUgLSB2aXN1YWxWaWV3cG9ydC53aWR0aCkgPFxuICAgIC8vIDAuMDAxXG4gICAgLy8gRmFsbGJhY2sgaGVyZTogXCJOb3QgU2FmYXJpXCIgdXNlckFnZW50XG5cbiAgICBpZiAoIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBtYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59IiwiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gXCIuL2dldFNjcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwiaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWaWV3cG9ydFJlY3QgZnJvbSBcIi4vZ2V0Vmlld3BvcnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gXCIuL2dldERvY3VtZW50UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4vY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IG1heCwgbWluIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpKSA6IGlzSFRNTEVsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciByZWZlcmVuY2VFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2VFbGVtZW50KTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCJpbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdmFyaWF0aW9uUGxhY2VtZW50cywgYmFzZVBsYWNlbWVudHMsIHBsYWNlbWVudHMgYXMgYWxsUGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGFsbFBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTtcblxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueScsICdwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb24nLCAnb2YgdGhlIGFsbG93ZWQgcGxhY2VtZW50cy4nLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwiaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuLi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3JlYWQnLFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB3aXRoaW4gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzIHx8IGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdIC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWU7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF1bbWFpbkF4aXNdIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihfbWluLCB0ZXRoZXJNaW4pIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gbWF0aE1heChfbWF4LCB0ZXRoZXJNYXgpIDogX21heCk7XG5cbiAgICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCk7XG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgdmFsaWRhdGVNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanNcIjtcbmltcG9ydCB1bmlxdWVCeSBmcm9tIFwiLi91dGlscy91bmlxdWVCeS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG5cblxuICAgICAgICAgIGlmIChbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX19kZWJ1Z19sb29wc19fID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcblxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9OyIsImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwiZnVuY3Rpb24gX2dldENlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllcigpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICAgICAgZm4oeyBzdGF0ZSB9KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgaWYgKG5hbWUgIT09ICdwb3BwZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcblxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYWRhcHRpdmU6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgYXJyYXkgb2Ygb3B0aW9ucyBmb3IgYSB0b29sdGlwIHRoYXQgZG9lc24ndCBoYXZlIGFcbiAqIHRhcmdldCBlbGVtZW50IGluIHRoZSBET00gLS0gYW5kIHRodXMgaXMgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyXG4gKiBvZiB0aGUgdmlld1xuICpcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZmluYWwgUG9wcGVyIG9wdGlvbnMgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ2VudGVyZWRQb3BwZXIoc3RlcCkge1xuICBjb25zdCBjZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIgPSBfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyKCk7XG5cbiAgbGV0IHBvcHBlck9wdGlvbnMgPSB7XG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICBzdHJhdGVneTogJ2ZpeGVkJyxcbiAgICBtb2RpZmllcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2ZvY3VzQWZ0ZXJSZW5kZXInLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwaGFzZTogJ2FmdGVyV3JpdGUnLFxuICAgICAgICBmbigpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGVwLmVsKSB7XG4gICAgICAgICAgICAgIHN0ZXAuZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9O1xuXG4gIHBvcHBlck9wdGlvbnMgPSB7XG4gICAgLi4ucG9wcGVyT3B0aW9ucyxcbiAgICBtb2RpZmllcnM6IEFycmF5LmZyb20oXG4gICAgICBuZXcgU2V0KFsuLi5wb3BwZXJPcHRpb25zLm1vZGlmaWVycywgLi4uY2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyXSlcbiAgICApXG4gIH07XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4vdHlwZS1jaGVjayc7XG5pbXBvcnQgeyBtYWtlQ2VudGVyZWRQb3BwZXIgfSBmcm9tICcuL3BvcHBlci1vcHRpb25zJztcblxuLyoqXG4gKiBFbnN1cmUgY2xhc3MgcHJlZml4IGVuZHMgaW4gYC1gXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gcHJlcGVuZCB0byB0aGUgY2xhc3MgbmFtZXMgZ2VuZXJhdGVkIGJ5IG5hbm8tY3NzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcmVmaXggZW5kaW5nIGluIGAtYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUHJlZml4KHByZWZpeCkge1xuICBpZiAoIWlzU3RyaW5nKHByZWZpeCkgfHwgcHJlZml4ID09PSAnJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBwcmVmaXguY2hhckF0KHByZWZpeC5sZW5ndGggLSAxKSAhPT0gJy0nID8gYCR7cHJlZml4fS1gIDogcHJlZml4O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBvcHRpb25zLmF0dGFjaFRvLmVsZW1lbnQgaXMgYSBzdHJpbmcsIGFuZCBpZiBzbywgdHJpZXMgdG8gZmluZCB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7e2VsZW1lbnQsIG9ufX1cbiAqIGBlbGVtZW50YCBpcyBhIHF1YWxpZmllZCBIVE1MIEVsZW1lbnRcbiAqIGBvbmAgaXMgYSBzdHJpbmcgcG9zaXRpb24gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXR0YWNoVG8oc3RlcCkge1xuICBjb25zdCBvcHRpb25zID0gc3RlcC5vcHRpb25zLmF0dGFjaFRvIHx8IHt9O1xuICBjb25zdCByZXR1cm5PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgaWYgKGlzU3RyaW5nKG9wdGlvbnMuZWxlbWVudCkpIHtcbiAgICAvLyBDYW4ndCBvdmVycmlkZSB0aGUgZWxlbWVudCBpbiB1c2VyIG9wdHMgcmVmZXJlbmNlIGJlY2F1c2Ugd2UgY2FuJ3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgZWxlbWVudCB3aWxsIGV4aXN0IGluIHRoZSBmdXR1cmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybk9wdHMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5lbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghcmV0dXJuT3B0cy5lbGVtZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgVGhlIGVsZW1lbnQgZm9yIHRoaXMgU2hlcGhlcmQgc3RlcCB3YXMgbm90IGZvdW5kICR7b3B0aW9ucy5lbGVtZW50fWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVybk9wdHM7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBvcHRpb25zIGZvciB0aGUgdG9vbHRpcCBhbmQgaW5pdGlhbGl6ZXNcbiAqIGBzdGVwLnRvb2x0aXBgIGFzIGEgUG9wcGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFRvb2x0aXAoc3RlcCkge1xuICBpZiAoc3RlcC50b29sdGlwKSB7XG4gICAgc3RlcC50b29sdGlwLmRlc3Ryb3koKTtcbiAgfVxuXG4gIGNvbnN0IGF0dGFjaFRvT3B0aW9ucyA9IHBhcnNlQXR0YWNoVG8oc3RlcCk7XG5cbiAgbGV0IHRhcmdldCA9IGF0dGFjaFRvT3B0aW9ucy5lbGVtZW50O1xuICBjb25zdCBwb3BwZXJPcHRpb25zID0gZ2V0UG9wcGVyT3B0aW9ucyhhdHRhY2hUb09wdGlvbnMsIHN0ZXApO1xuXG4gIGlmIChzdGVwLmlzQ2VudGVyZWQoKSkge1xuICAgIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgY29udGVudCA9IHN0ZXAuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLWNlbnRlcmVkJyk7XG4gIH1cblxuICBzdGVwLnRvb2x0aXAgPSBjcmVhdGVQb3BwZXIodGFyZ2V0LCBzdGVwLmVsLCBwb3BwZXJPcHRpb25zKTtcbiAgc3RlcC50YXJnZXQgPSBhdHRhY2hUb09wdGlvbnMuZWxlbWVudDtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB1bmlxdWUgaWQgZm9yIHN0ZXBzLCB0b3VycywgbW9kYWxzLCBldGNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIGxldCBkID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYFBvcHBlcmAgb3B0aW9ucyBmcm9tIGEgc2V0IG9mIGJhc2UgYGF0dGFjaFRvYCBvcHRpb25zXG4gKiBAcGFyYW0gYXR0YWNoVG9PcHRpb25zXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3BwZXJPcHRpb25zKGF0dGFjaFRvT3B0aW9ucywgc3RlcCkge1xuICBsZXQgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICBtb2RpZmllcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhbHRBeGlzOiB0cnVlLFxuICAgICAgICAgIHRldGhlcjogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2ZvY3VzQWZ0ZXJSZW5kZXInLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwaGFzZTogJ2FmdGVyV3JpdGUnLFxuICAgICAgICBmbigpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGVwLmVsKSB7XG4gICAgICAgICAgICAgIHN0ZXAuZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJ1xuICB9O1xuXG4gIGlmIChzdGVwLmlzQ2VudGVyZWQoKSkge1xuICAgIHBvcHBlck9wdGlvbnMgPSBtYWtlQ2VudGVyZWRQb3BwZXIoc3RlcCk7XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT3B0aW9ucy5wbGFjZW1lbnQgPSBhdHRhY2hUb09wdGlvbnMub247XG4gIH1cblxuICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnMgPVxuICAgIHN0ZXAudG91ciAmJiBzdGVwLnRvdXIub3B0aW9ucyAmJiBzdGVwLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG5cbiAgaWYgKGRlZmF1bHRTdGVwT3B0aW9ucykge1xuICAgIHBvcHBlck9wdGlvbnMgPSBfbWVyZ2VNb2RpZmllcnMoZGVmYXVsdFN0ZXBPcHRpb25zLCBwb3BwZXJPcHRpb25zKTtcbiAgfVxuXG4gIHBvcHBlck9wdGlvbnMgPSBfbWVyZ2VNb2RpZmllcnMoc3RlcC5vcHRpb25zLCBwb3BwZXJPcHRpb25zKTtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cblxuZnVuY3Rpb24gX21lcmdlTW9kaWZpZXJzKHN0ZXBPcHRpb25zLCBwb3BwZXJPcHRpb25zKSB7XG4gIGlmIChzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zKSB7XG4gICAgbGV0IG1lcmdlZFBvcHBlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBwb3BwZXJPcHRpb25zLFxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9uc1xuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycyAmJlxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgY29uc3QgbmFtZXMgPSBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycy5tYXAoKG1vZCkgPT4gbW9kLm5hbWUpO1xuICAgICAgY29uc3QgZmlsdGVyZWRNb2RpZmllcnMgPSBwb3BwZXJPcHRpb25zLm1vZGlmaWVycy5maWx0ZXIoXG4gICAgICAgIChtb2QpID0+ICFuYW1lcy5pbmNsdWRlcyhtb2QubmFtZSlcbiAgICAgICk7XG5cbiAgICAgIG1lcmdlZFBvcHBlck9wdGlvbnMubW9kaWZpZXJzID0gQXJyYXkuZnJvbShcbiAgICAgICAgbmV3IFNldChbLi4uZmlsdGVyZWRNb2RpZmllcnMsIC4uLnN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzXSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZFBvcHBlck9wdGlvbnM7XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cbiIsImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgIGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcbiAgICAgICAgbG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bihmbikge1xuICAgIHJldHVybiBmbigpO1xufVxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgICBmbnMuZm9yRWFjaChydW4pO1xufVxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5mdW5jdGlvbiBpc19lbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zdG9yZShzdG9yZSwgbmFtZSkge1xuICAgIGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtuYW1lfScgaXMgbm90IGEgc3RvcmUgd2l0aCBhICdzdWJzY3JpYmUnIG1ldGhvZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgaWYgKHN0b3JlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHN1YnNjcmliZShzdG9yZSwgXyA9PiB2YWx1ZSA9IF8pKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29tcG9uZW50X3N1YnNjcmliZShjb21wb25lbnQsIHN0b3JlLCBjYWxsYmFjaykge1xuICAgIGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuXG4gICAgICAgID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpXG4gICAgICAgIDogJCRzY29wZS5jdHg7XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG4gICAgICAgIGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG4gICAgICAgIGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuICAgIH1cbiAgICByZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9zcHJlYWQoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuLCBnZXRfc2xvdF9zcHJlYWRfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X3NwcmVhZF9jaGFuZ2VzX2ZuKGRpcnR5KSB8IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleGNsdWRlX2ludGVybmFsX3Byb3BzKHByb3BzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoa1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdWx0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfcmVzdF9wcm9wcyhwcm9wcywga2V5cykge1xuICAgIGNvbnN0IHJlc3QgPSB7fTtcbiAgICBrZXlzID0gbmV3IFNldChrZXlzKTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmICgha2V5cy5oYXMoaykgJiYga1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChyYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUgPSByZXQpIHtcbiAgICBzdG9yZS5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59XG5jb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG4gICAgcmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbmNvbnN0IGlzX2NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xubGV0IG5vdyA9IGlzX2NsaWVudFxuICAgID8gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgOiAoKSA9PiBEYXRlLm5vdygpO1xubGV0IHJhZiA9IGlzX2NsaWVudCA/IGNiID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikgOiBub29wO1xuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBzZXRfbm93KGZuKSB7XG4gICAgbm93ID0gZm47XG59XG5mdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG4gICAgcmFmID0gZm47XG59XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcnVuX3Rhc2tzKG5vdykge1xuICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgIGlmICghdGFzay5jKG5vdykpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgICAgIHRhc2suZigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhc2tzLnNpemUgIT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xufVxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICovXG5mdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcbiAgICB0YXNrcy5jbGVhcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICovXG5mdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRhc2s7XG4gICAgaWYgKHRhc2tzLnNpemUgPT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bGZpbGwgPT4ge1xuICAgICAgICAgICAgdGFza3MuYWRkKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlbGYoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcylcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3JzW2tleV0gJiYgZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmNoZWNrZWQpXG4gICAgICAgICAgICB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgICB2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Zykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgICAgICB3aGlsZSAoaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbaisrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlbW92ZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHJlbW92ZVtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZXMuc3BsaWNlKGksIDEpWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdmcgPyBzdmdfZWxlbWVudChuYW1lKSA6IGVsZW1lbnQobmFtZSk7XG59XG5mdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSAnJyArIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXMuc3BsaWNlKGksIDEpWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0KGRhdGEpO1xufVxuZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhKHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCAhPT0gZGF0YSlcbiAgICAgICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuICAgIGNvbnN0IHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpIHx8IHNlbGVjdC5vcHRpb25zWzBdO1xuICAgIHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5mdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG4gICAgcmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCBvcHRpb24gPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5sZXQgY3Jvc3NvcmlnaW47XG5mdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcbiAgICBpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjcm9zc29yaWdpbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjcm9zc29yaWdpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuZnVuY3Rpb24gYWRkX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuICAgIGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuICAgICAgICAnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3Rlbih3aW5kb3csICdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZChub2RlLCBpZnJhbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2goaWZyYW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0W3RvZ2dsZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xufVxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIGRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuY2xhc3MgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yID0gbnVsbCkge1xuICAgICAgICB0aGlzLmEgPSBhbmNob3I7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgfVxuICAgIG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgICAgICB0aGlzLmUgPSBlbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pKGFuY2hvcik7XG4gICAgfVxuICAgIGgoaHRtbCkge1xuICAgICAgICB0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUuY2hpbGROb2Rlcyk7XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcChodG1sKSB7XG4gICAgICAgIHRoaXMuZCgpO1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICAgIHRoaXMuaSh0aGlzLmEpO1xuICAgIH1cbiAgICBkKCkge1xuICAgICAgICB0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgYWN0aXZlX2RvY3MgPSBuZXcgU2V0KCk7XG5sZXQgYWN0aXZlID0gMDtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBhY3RpdmVfZG9jcy5hZGQoZG9jKTtcbiAgICBjb25zdCBzdHlsZXNoZWV0ID0gZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQgfHwgKGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0ID0gZG9jLmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCgnc3R5bGUnKSkuc2hlZXQpO1xuICAgIGNvbnN0IGN1cnJlbnRfcnVsZXMgPSBkb2MuX19zdmVsdGVfcnVsZXMgfHwgKGRvYy5fX3N2ZWx0ZV9ydWxlcyA9IHt9KTtcbiAgICBpZiAoIWN1cnJlbnRfcnVsZXNbbmFtZV0pIHtcbiAgICAgICAgY3VycmVudF9ydWxlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnO1xuICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnfSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuICAgIGFjdGl2ZSArPSAxO1xuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZGVsZXRlX3J1bGUobm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKG5hbWVcbiAgICAgICAgPyBhbmltID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICA6IGFuaW0gPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG4gICAgKTtcbiAgICBjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG4gICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgICAgIGFjdGl2ZSAtPSBkZWxldGVkO1xuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNsZWFyX3J1bGVzKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYWN0aXZlX2RvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0O1xuICAgICAgICAgICAgbGV0IGkgPSBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldC5kZWxldGVSdWxlKGkpO1xuICAgICAgICAgICAgZG9jLl9fc3ZlbHRlX3J1bGVzID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICBhY3RpdmVfZG9jcy5jbGVhcigpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfYW5pbWF0aW9uKG5vZGUsIGZyb20sIGZuLCBwYXJhbXMpIHtcbiAgICBpZiAoIWZyb20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZnJvbS5sZWZ0ID09PSB0by5sZWZ0ICYmIGZyb20ucmlnaHQgPT09IHRvLnJpZ2h0ICYmIGZyb20udG9wID09PSB0by50b3AgJiYgZnJvbS5ib3R0b20gPT09IHRvLmJvdHRvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBzaG91bGQgdGhpcyBiZSBzZXBhcmF0ZWQgZnJvbSBkZXN0cnVjdHVyaW5nPyBPciBzdGFydC9lbmQgYWRkZWQgdG8gcHVibGljIGFwaSBhbmQgZG9jdW1lbnRhdGlvbj9cbiAgICBzdGFydDogc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzpcbiAgICBlbmQgPSBzdGFydF90aW1lICsgZHVyYXRpb24sIHRpY2sgPSBub29wLCBjc3MgfSA9IGZuKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbmFtZTtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXkpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBuYW1lKTtcbiAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgIGlmICghc3RhcnRlZCAmJiBub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQgJiYgbm93ID49IGVuZCkge1xuICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHN0YXJ0X3RpbWU7XG4gICAgICAgICAgICBjb25zdCB0ID0gMCArIDEgKiBlYXNpbmcocCAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHN0YXJ0KCk7XG4gICAgdGljaygwLCAxKTtcbiAgICByZXR1cm4gc3RvcDtcbn1cbmZ1bmN0aW9uIGZpeF9wb3NpdGlvbihub2RlKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHN0eWxlO1xuICAgICAgICBjb25zdCBhID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGFkZF90cmFuc2Zvcm0obm9kZSwgYSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkX3RyYW5zZm9ybShub2RlLCBhKSB7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGEubGVmdCAhPT0gYi5sZWZ0IHx8IGEudG9wICE9PSBiLnRvcCkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gYCR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHthLmxlZnQgLSBiLmxlZnR9cHgsICR7YS50b3AgLSBiLnRvcH1weClgO1xuICAgIH1cbn1cblxubGV0IGN1cnJlbnRfY29tcG9uZW50O1xuZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuICAgIGlmICghY3VycmVudF9jb21wb25lbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG4gICAgcmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICByZXR1cm4gKHR5cGUsIGRldGFpbCkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5mdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmhhcyhrZXkpO1xufVxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbmZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4oZXZlbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5jb25zdCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmxldCBmbHVzaGluZyA9IGZhbHNlO1xuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBpZiAoZmx1c2hpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgYmluZGluZ19jYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgLy8gdGhlbiwgb25jZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLCBjYWxsXG4gICAgICAgIC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2VcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSByZW5kZXJfY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWVuX2NhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uc28gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBsb29wc1xuICAgICAgICAgICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuICAgIHdoaWxlIChmbHVzaF9jYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgIH1cbiAgICB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuICAgIGdyb3VwLnIgKz0gMTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMSwgMCwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ3N0YXJ0JykpO1xuICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWdyb3VwLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCByZXN1bHQgaW4gYGVuZCgpYCBiZWluZyBjYWxsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGNsZWFuIHVwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwoZ3JvdXAuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSAtIHQsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdvKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuZChyZXNldCkge1xuICAgICAgICAgICAgaWYgKHJlc2V0ICYmIGNvbmZpZy50aWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRpY2soMSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHQgPSBpbnRybyA/IDAgOiAxO1xuICAgIGxldCBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgIGxldCBhbmltYXRpb25fbmFtZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZCA9IHByb2dyYW0uYiAtIHQ7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgICAgIGlmICghaW5mby5oYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSBwcm9taXNlO1xuICAgIH1cbn1cblxuY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgIDogZ2xvYmFsKTtcblxuZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZCgxKTtcbiAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG59XG5mdW5jdGlvbiBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBvdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gICAgbGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcbiAgICBsZXQgbiA9IGxpc3QubGVuZ3RoO1xuICAgIGxldCBpID0gbztcbiAgICBjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gICAgY29uc3QgbmV3X2Jsb2NrcyA9IFtdO1xuICAgIGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVsdGFzID0gbmV3IE1hcCgpO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIGJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X2xvb2t1cC5zZXQoa2V5LCBuZXdfYmxvY2tzW2ldID0gYmxvY2spO1xuICAgICAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKVxuICAgICAgICAgICAgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG4gICAgfVxuICAgIGNvbnN0IHdpbGxfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgIGJsb2NrLm0obm9kZSwgbmV4dCk7XG4gICAgICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgICAgIG5leHQgPSBibG9jay5maXJzdDtcbiAgICAgICAgbi0tO1xuICAgIH1cbiAgICB3aGlsZSAobyAmJiBuKSB7XG4gICAgICAgIGNvbnN0IG5ld19ibG9jayA9IG5ld19ibG9ja3NbbiAtIDFdO1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW28gLSAxXTtcbiAgICAgICAgY29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG4gICAgICAgIGNvbnN0IG9sZF9rZXkgPSBvbGRfYmxvY2sua2V5O1xuICAgICAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIGJsb2NrXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbG9va3VwLmhhcyhuZXdfa2V5KSB8fCB3aWxsX21vdmUuaGFzKG5ld19rZXkpKSB7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuICAgICAgICAgICAgZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWxsX21vdmUuYWRkKG9sZF9rZXkpO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChvLS0pIHtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvXTtcbiAgICAgICAgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfYmxvY2sua2V5KSlcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgIH1cbiAgICB3aGlsZSAobilcbiAgICAgICAgaW5zZXJ0KG5ld19ibG9ja3NbbiAtIDFdKTtcbiAgICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpKTtcbiAgICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoJyk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zcHJlYWRfdXBkYXRlKGxldmVscywgdXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgIGNvbnN0IHRvX251bGxfb3V0ID0ge307XG4gICAgY29uc3QgYWNjb3VudGVkX2ZvciA9IHsgJCRzY29wZTogMSB9O1xuICAgIGxldCBpID0gbGV2ZWxzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IG8gPSBsZXZlbHNbaV07XG4gICAgICAgIGNvbnN0IG4gPSB1cGRhdGVzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBuKSlcbiAgICAgICAgICAgICAgICAgICAgdG9fbnVsbF9vdXRba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50ZWRfZm9yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlW2tleV0gPSBuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxzW2ldID0gbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvX251bGxfb3V0KSB7XG4gICAgICAgIGlmICghKGtleSBpbiB1cGRhdGUpKVxuICAgICAgICAgICAgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBnZXRfc3ByZWFkX29iamVjdChzcHJlYWRfcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG5jb25zdCBib29sZWFuX2F0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgICAnYWxsb3dmdWxsc2NyZWVuJyxcbiAgICAnYWxsb3dwYXltZW50cmVxdWVzdCcsXG4gICAgJ2FzeW5jJyxcbiAgICAnYXV0b2ZvY3VzJyxcbiAgICAnYXV0b3BsYXknLFxuICAgICdjaGVja2VkJyxcbiAgICAnY29udHJvbHMnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZGVmZXInLFxuICAgICdkaXNhYmxlZCcsXG4gICAgJ2Zvcm1ub3ZhbGlkYXRlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaXNtYXAnLFxuICAgICdsb29wJyxcbiAgICAnbXVsdGlwbGUnLFxuICAgICdtdXRlZCcsXG4gICAgJ25vbW9kdWxlJyxcbiAgICAnbm92YWxpZGF0ZScsXG4gICAgJ29wZW4nLFxuICAgICdwbGF5c2lubGluZScsXG4gICAgJ3JlYWRvbmx5JyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyZXZlcnNlZCcsXG4gICAgJ3NlbGVjdGVkJ1xuXSk7XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGNsYXNzZXNfdG9fYWRkKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuICAgIGlmIChjbGFzc2VzX3RvX2FkZCkge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5jbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IGAgJHtuYW1lfT1cIiR7U3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9cIi9nLCAnJiMzNDsnKS5yZXBsYWNlKC8nL2csICcmIzM5OycpfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBlc2NhcGVkID0ge1xuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7J1xufTtcbmZ1bmN0aW9uIGVzY2FwZShodG1sKSB7XG4gICAgcmV0dXJuIFN0cmluZyhodG1sKS5yZXBsYWNlKC9bXCInJjw+XS9nLCBtYXRjaCA9PiBlc2NhcGVkW21hdGNoXSk7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzYCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1ZyhmaWxlLCBsaW5lLCBjb2x1bW4sIHZhbHVlcykge1xuICAgIGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4gJyc7XG59XG5sZXQgb25fZGVzdHJveTtcbmZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG4gICAgZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICAgICAgY29uc3QgJCQgPSB7XG4gICAgICAgICAgICBvbl9kZXN0cm95LFxuICAgICAgICAgICAgY29udGV4dDogbmV3IE1hcChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogY29udGV4dCB8fCBbXSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gYCAke25hbWV9JHt2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYD0ke3R5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeShlc2NhcGUodmFsdWUpKSA6IGBcIiR7dmFsdWV9XCJgfWB9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgb25fbW91bnQsIG9uX2Rlc3Ryb3ksIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgaWYgKG9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBvbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogbnVsbCxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IG9wdGlvbnMuY29udGV4dCB8fCBbXSksXG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICBkaXJ0eSxcbiAgICAgICAgc2tpcF9ib3VuZDogZmFsc2VcbiAgICB9O1xuICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgICQkLmN0eCA9IGluc3RhbmNlXG4gICAgICAgID8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcbiAgICAgICAgICAgIGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgJCQuY3R4W2ldID0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKVxuICAgICAgICAgICAgICAgICAgICAkJC5ib3VuZFtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KVxuICAgICAgICAgICAgICAgICAgICBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KVxuICAgICAgICA6IFtdO1xuICAgICQkLnVwZGF0ZSgpO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgIC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuICAgICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjM3LjAnIH0sIGRldGFpbCkpKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuICAgIGRldGFjaChub2RlKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuICAgIHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuX2Rldihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucywgaGFzX3ByZXZlbnRfZGVmYXVsdCwgaGFzX3N0b3BfcHJvcGFnYXRpb24pIHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBvcHRpb25zID09PSB0cnVlID8gWydjYXB0dXJlJ10gOiBvcHRpb25zID8gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvcHRpb25zKSkgOiBbXTtcbiAgICBpZiAoaGFzX3ByZXZlbnRfZGVmYXVsdClcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3ByZXZlbnREZWZhdWx0Jyk7XG4gICAgaWYgKGhhc19zdG9wX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcFByb3BhZ2F0aW9uJyk7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcbiAgICBlbHNlXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJiAhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhcmcpKSB7XG4gICAgICAgIGxldCBtc2cgPSAneyNlYWNofSBvbmx5IGl0ZXJhdGVzIG92ZXIgYXJyYXktbGlrZSBvYmplY3RzLic7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGFyZyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnKSB7XG4gICAgICAgICAgICBtc2cgKz0gJyBZb3UgY2FuIHVzZSBhIHNwcmVhZCB0byBjb252ZXJ0IHRoaXMgaXRlcmFibGUgaW50byBhbiBhcnJheS4nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3Nsb3RzKG5hbWUsIHNsb3QsIGtleXMpIHtcbiAgICBmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG4gICAgICAgIGlmICghfmtleXMuaW5kZXhPZihzbG90X2tleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgPCR7bmFtZX0+IHJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgc2xvdCBcIiR7c2xvdF9rZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzIHdpdGggc29tZSBtaW5vciBkZXYtZW5oYW5jZW1lbnRzLiBVc2VkIHdoZW4gZGV2PXRydWUuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudERldiBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgKCFvcHRpb25zLnRhcmdldCAmJiAhb3B0aW9ucy4kJGlubGluZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIid0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb21wb25lbnQgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAkY2FwdHVyZV9zdGF0ZSgpIHsgfVxuICAgICRpbmplY3Rfc3RhdGUoKSB7IH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyB0byBjcmVhdGUgc3Ryb25nbHkgdHlwZWQgU3ZlbHRlIGNvbXBvbmVudHMuXG4gKiBUaGlzIG9ubHkgZXhpc3RzIGZvciB0eXBpbmcgcHVycG9zZXMgYW5kIHNob3VsZCBiZSB1c2VkIGluIGAuZC50c2AgZmlsZXMuXG4gKlxuICogIyMjIEV4YW1wbGU6XG4gKlxuICogWW91IGhhdmUgY29tcG9uZW50IGxpYnJhcnkgb24gbnBtIGNhbGxlZCBgY29tcG9uZW50LWxpYnJhcnlgLCBmcm9tIHdoaWNoXG4gKiB5b3UgZXhwb3J0IGEgY29tcG9uZW50IGNhbGxlZCBgTXlDb21wb25lbnRgLiBGb3IgU3ZlbHRlK1R5cGVTY3JpcHQgdXNlcnMsXG4gKiB5b3Ugd2FudCB0byBwcm92aWRlIHR5cGluZ3MuIFRoZXJlZm9yZSB5b3UgY3JlYXRlIGEgYGluZGV4LmQudHNgOlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFN2ZWx0ZUNvbXBvbmVudFR5cGVkIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50VHlwZWQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGBgYFxuICogVHlwaW5nIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIElERXMgbGlrZSBWUyBDb2RlIHdpdGggdGhlIFN2ZWx0ZSBleHRlbnNpb25cbiAqIHRvIHByb3ZpZGUgaW50ZWxsaXNlbnNlIGFuZCB0byB1c2UgdGhlIGNvbXBvbmVudCBsaWtlIHRoaXMgaW4gYSBTdmVsdGUgZmlsZVxuICogd2l0aCBUeXBlU2NyaXB0OlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICogXHRpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gXCJjb21wb25lbnQtbGlicmFyeVwiO1xuICogPC9zY3JpcHQ+XG4gKiA8TXlDb21wb25lbnQgZm9vPXsnYmFyJ30gLz5cbiAqIGBgYFxuICpcbiAqICMjIyMgV2h5IG5vdCBtYWtlIHRoaXMgcGFydCBvZiBgU3ZlbHRlQ29tcG9uZW50KERldilgP1xuICogQmVjYXVzZVxuICogYGBgdHNcbiAqIGNsYXNzIEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50PHtmb286IHN0cmluZ30+IHt9XG4gKiBjb25zdCBjb21wb25lbnQ6IHR5cGVvZiBTdmVsdGVDb21wb25lbnQgPSBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudDtcbiAqIGBgYFxuICogd2lsbCB0aHJvdyBhIHR5cGUgZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2VwZXJhdGUgdGhlIG1vcmUgc3RyaWN0bHkgdHlwZWQgY2xhc3MuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkIGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50RGV2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvb3BfZ3VhcmQodGltZW91dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIGRldGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgeyBIdG1sVGFnLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9sb2NhdGlvbiwgYWRkX3JlbmRlcl9jYWxsYmFjaywgYWRkX3Jlc2l6ZV9saXN0ZW5lciwgYWRkX3RyYW5zZm9ybSwgYWZ0ZXJVcGRhdGUsIGFwcGVuZCwgYXBwZW5kX2RldiwgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1fc3BhY2UsIGNsYWltX3RleHQsIGNsZWFyX2xvb3BzLCBjb21wb25lbnRfc3Vic2NyaWJlLCBjb21wdXRlX3Jlc3RfcHJvcHMsIGNvbXB1dGVfc2xvdHMsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgY3JlYXRlX2FuaW1hdGlvbiwgY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbiwgY3JlYXRlX2NvbXBvbmVudCwgY3JlYXRlX2luX3RyYW5zaXRpb24sIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbiwgY3JlYXRlX3Nsb3QsIGNyZWF0ZV9zc3JfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCwgY3VzdG9tX2V2ZW50LCBkYXRhc2V0X2RldiwgZGVidWcsIGRlc3Ryb3lfYmxvY2ssIGRlc3Ryb3lfY29tcG9uZW50LCBkZXN0cm95X2VhY2gsIGRldGFjaCwgZGV0YWNoX2FmdGVyX2RldiwgZGV0YWNoX2JlZm9yZV9kZXYsIGRldGFjaF9iZXR3ZWVuX2RldiwgZGV0YWNoX2RldiwgZGlydHlfY29tcG9uZW50cywgZGlzcGF0Y2hfZGV2LCBlYWNoLCBlbGVtZW50LCBlbGVtZW50X2lzLCBlbXB0eSwgZXNjYXBlLCBlc2NhcGVkLCBleGNsdWRlX2ludGVybmFsX3Byb3BzLCBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9wb3NpdGlvbiwgZmx1c2gsIGdldENvbnRleHQsIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlLCBnZXRfY3VycmVudF9jb21wb25lbnQsIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsIGdldF9zbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHQsIGdldF9zcHJlYWRfb2JqZWN0LCBnZXRfc3ByZWFkX3VwZGF0ZSwgZ2V0X3N0b3JlX3ZhbHVlLCBnbG9iYWxzLCBncm91cF9vdXRyb3MsIGhhbmRsZV9wcm9taXNlLCBoYXNDb250ZXh0LCBoYXNfcHJvcCwgaWRlbnRpdHksIGluaXQsIGluc2VydCwgaW5zZXJ0X2RldiwgaW50cm9zLCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciwgaXNfY2xpZW50LCBpc19jcm9zc29yaWdpbiwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBpc19wcm9taXNlLCBsaXN0ZW4sIGxpc3Rlbl9kZXYsIGxvb3AsIGxvb3BfZ3VhcmQsIG1pc3NpbmdfY29tcG9uZW50LCBtb3VudF9jb21wb25lbnQsIG5vb3AsIG5vdF9lcXVhbCwgbm93LCBudWxsX3RvX2VtcHR5LCBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzLCBvbkRlc3Ryb3ksIG9uTW91bnQsIG9uY2UsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBwcmV2ZW50X2RlZmF1bHQsIHByb3BfZGV2LCBxdWVyeV9zZWxlY3Rvcl9hbGwsIHJhZiwgcnVuLCBydW5fYWxsLCBzYWZlX25vdF9lcXVhbCwgc2NoZWR1bGVfdXBkYXRlLCBzZWxlY3RfbXVsdGlwbGVfdmFsdWUsIHNlbGVjdF9vcHRpb24sIHNlbGVjdF9vcHRpb25zLCBzZWxlY3RfdmFsdWUsIHNlbGYsIHNldENvbnRleHQsIHNldF9hdHRyaWJ1dGVzLCBzZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhLCBzZXRfZGF0YSwgc2V0X2RhdGFfZGV2LCBzZXRfaW5wdXRfdHlwZSwgc2V0X2lucHV0X3ZhbHVlLCBzZXRfbm93LCBzZXRfcmFmLCBzZXRfc3RvcmVfdmFsdWUsIHNldF9zdHlsZSwgc2V0X3N2Z19hdHRyaWJ1dGVzLCBzcGFjZSwgc3ByZWFkLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X3NwcmVhZCwgdmFsaWRhdGVfY29tcG9uZW50LCB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50LCB2YWxpZGF0ZV9lYWNoX2tleXMsIHZhbGlkYXRlX3Nsb3RzLCB2YWxpZGF0ZV9zdG9yZSwgeGxpbmtfYXR0ciB9O1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuXG4gIGV4cG9ydCBsZXQgY29uZmlnLCBzdGVwO1xuICBsZXQgYWN0aW9uLCBjbGFzc2VzLCBkaXNhYmxlZCwgbGFiZWwsIHNlY29uZGFyeSwgdGV4dDtcblxuICAkOiB7XG4gICAgYWN0aW9uID0gY29uZmlnLmFjdGlvbiA/IGNvbmZpZy5hY3Rpb24uYmluZChzdGVwLnRvdXIpIDogbnVsbDtcbiAgICBjbGFzc2VzID0gY29uZmlnLmNsYXNzZXM7XG4gICAgZGlzYWJsZWQgPSBjb25maWcuZGlzYWJsZWQgPyBnZXREaXNhYmxlZChjb25maWcuZGlzYWJsZWQpIDogZmFsc2U7XG4gICAgbGFiZWwgPSBjb25maWcubGFiZWw7XG4gICAgc2Vjb25kYXJ5ID0gY29uZmlnLnNlY29uZGFyeTtcbiAgICB0ZXh0ID0gY29uZmlnLnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZGlzYWJsZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGRpc2FibGVkID0gZGlzYWJsZWQuY2FsbChzdGVwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXNhYmxlZFxuICB9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtYnV0dG9uIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoNTAsIDEzNiwgMjMwKTtcbiAgICBib3JkZXI6IDA7XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTtcbiAgICBwYWRkaW5nOiAwLjVyZW0gMS41cmVtO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2U7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjUsIDExMSwgMjA0KTtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b24uc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeSB7XG4gICAgYmFja2dyb3VuZDogcmdiKDI0MSwgMjQyLCAyNDMpO1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbi5zaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5Om5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjE0LCAyMTcsIDIxOSk7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uOmRpc2FibGVkIHtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICB9XG48L3N0eWxlPlxuXG48YnV0dG9uXG4gIGFyaWEtbGFiZWw9XCJ7bGFiZWwgPyBsYWJlbCA6IG51bGx9XCJcbiAgY2xhc3M9XCJ7YCR7KGNsYXNzZXMgfHwgJycpfSBzaGVwaGVyZC1idXR0b24gJHsoc2Vjb25kYXJ5ID8gJ3NoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnknIDogJycpfWB9XCJcbiAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICBvbjpjbGljaz17YWN0aW9ufVxuICB0YWJpbmRleD1cIjBcIlxuPlxuICAgIHtAaHRtbCB0ZXh0fVxuPC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRCdXR0b24gZnJvbSAnLi9zaGVwaGVyZC1idXR0b24uc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IHN0ZXA7XG5cbiAgJDogYnV0dG9ucyA9IHN0ZXAub3B0aW9ucy5idXR0b25zO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1mb290ZXIge1xuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDVweDtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNXB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBwYWRkaW5nOiAwIDAuNzVyZW0gMC43NXJlbTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1mb290ZXIgLnNoZXBoZXJkLWJ1dHRvbjpsYXN0LWNoaWxkIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxmb290ZXIgY2xhc3M9XCJzaGVwaGVyZC1mb290ZXJcIj5cbiAgICB7I2lmIGJ1dHRvbnN9XG4gICAgICAgIHsjZWFjaCBidXR0b25zIGFzIGNvbmZpZ31cbiAgICAgICAgICA8U2hlcGhlcmRCdXR0b25cbiAgICAgICAgICAgIHtjb25maWd9XG4gICAgICAgICAgICB7c3RlcH1cbiAgICAgICAgICAvPlxuICAgICAgICB7L2VhY2h9XG4gICAgey9pZn1cbjwvZm9vdGVyPlxuIiwiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBjYW5jZWxJY29uLCBzdGVwO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjbGljayBsaXN0ZW5lciB0byB0aGUgY2FuY2VsIGxpbmsgdGhhdCBjYW5jZWxzIHRoZSB0b3VyXG4gICAqL1xuICBjb25zdCBoYW5kbGVDYW5jZWxDbGljayA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN0ZXAuY2FuY2VsKCk7XG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWNhbmNlbC1pY29uIHtcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC43NSk7XG4gICAgZm9udC1zaXplOiAyZW07XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgdHJhbnNpdGlvbjogY29sb3IgMC41cyBlYXNlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWNhbmNlbC1pY29uOmhvdmVyIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWNhbmNlbC1pY29uIHtcbiAgICBjb2xvcjogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWNhbmNlbC1pY29uOmhvdmVyIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuPC9zdHlsZT5cblxuPGJ1dHRvblxuICBhcmlhLWxhYmVsPVwie2NhbmNlbEljb24ubGFiZWwgPyBjYW5jZWxJY29uLmxhYmVsIDogJ0Nsb3NlIFRvdXInfVwiXG4gIGNsYXNzPVwic2hlcGhlcmQtY2FuY2VsLWljb25cIlxuICBvbjpjbGljaz17aGFuZGxlQ2FuY2VsQ2xpY2t9XG4gIHR5cGU9XCJidXR0b25cIlxuPlxuICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuPC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcbiAgXG4gIGV4cG9ydCBsZXQgbGFiZWxJZCwgZWxlbWVudCwgdGl0bGU7XG4gIFxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGl0bGUpKSB7XG4gICAgICB0aXRsZSA9IHRpdGxlKCk7XG4gICAgfVxuICAgIFxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGl0bGU7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC10aXRsZSB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmb250LXNpemU6IDFyZW07XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBmbGV4OiAxIDAgYXV0bztcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGgzXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgaWQ9XCJ7bGFiZWxJZH1cIlxuICBjbGFzcz1cInNoZXBoZXJkLXRpdGxlXCJcbj5cbjwvaDM+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRDYW5jZWxJY29uIGZyb20gJy4vc2hlcGhlcmQtY2FuY2VsLWljb24uc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkVGl0bGUgZnJvbSAnLi9zaGVwaGVyZC10aXRsZS5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQgbGFiZWxJZCwgc3RlcDtcbiAgbGV0IHRpdGxlLCBjYW5jZWxJY29uO1xuXG4gICQ6IHtcbiAgICAgIHRpdGxlID0gc3RlcC5vcHRpb25zLnRpdGxlO1xuICAgICAgY2FuY2VsSWNvbiA9IHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWhlYWRlciB7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgbGluZS1oZWlnaHQ6IDJlbTtcbiAgICBwYWRkaW5nOiAwLjc1cmVtIDAuNzVyZW0gMDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1oYXMtdGl0bGUgLnNoZXBoZXJkLWNvbnRlbnQgLnNoZXBoZXJkLWhlYWRlciB7XG4gICAgYmFja2dyb3VuZDogI2U2ZTZlNjtcbiAgICBwYWRkaW5nOiAxZW07XG4gIH1cbjwvc3R5bGU+XG5cbjxoZWFkZXIgY2xhc3M9XCJzaGVwaGVyZC1oZWFkZXJcIj5cbiAgICB7I2lmIHRpdGxlfVxuICAgICAgPFNoZXBoZXJkVGl0bGVcbiAgICAgICAge2xhYmVsSWR9XG4gICAgICAgIHt0aXRsZX1cbiAgICAgIC8+XG4gICAgey9pZn1cblxuICAgIHsjaWYgY2FuY2VsSWNvbiAmJiBjYW5jZWxJY29uLmVuYWJsZWR9XG4gICAgICA8U2hlcGhlcmRDYW5jZWxJY29uXG4gICAgICAgIHtjYW5jZWxJY29ufVxuICAgICAgICB7c3RlcH1cbiAgICAgIC8+XG4gICAgey9pZn1cbjwvaGVhZGVyPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG5cbiAgZXhwb3J0IGxldCBkZXNjcmlwdGlvbklkLCBlbGVtZW50LCBzdGVwO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBsZXQgeyB0ZXh0IH0gPSBzdGVwLm9wdGlvbnM7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih0ZXh0KSkge1xuICAgICAgdGV4dCA9IHRleHQuY2FsbChzdGVwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0ZXh0KSkge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgIH1cbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLXRleHQge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBsaW5lLWhlaWdodDogMS4zZW07XG4gICAgcGFkZGluZzogMC43NWVtO1xuICB9XG5cbiAgLnNoZXBoZXJkLXRleHQgcCB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgfVxuXG4gIC5zaGVwaGVyZC10ZXh0IHA6bGFzdC1jaGlsZCB7XG4gICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzPVwic2hlcGhlcmQtdGV4dFwiXG4gIGlkPVwie2Rlc2NyaXB0aW9uSWR9XCJcbj5cbjwvZGl2PlxuXG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgU2hlcGhlcmRGb290ZXIgZnJvbSAnLi9zaGVwaGVyZC1mb290ZXIuc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkSGVhZGVyIGZyb20gJy4vc2hlcGhlcmQtaGVhZGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZFRleHQgZnJvbSAnLi9zaGVwaGVyZC10ZXh0LnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5cbiAgZXhwb3J0IGxldCBkZXNjcmlwdGlvbklkLCBsYWJlbElkLCBzdGVwO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1jb250ZW50IHtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGNsYXNzPVwic2hlcGhlcmQtY29udGVudFwiXG4+XG4gIHsjaWYgIWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50aXRsZSkgfHwgKHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQpfVxuICAgIDxTaGVwaGVyZEhlYWRlclxuICAgICAge2xhYmVsSWR9XG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuXG4gIHsjaWYgIWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50ZXh0KX1cbiAgICA8U2hlcGhlcmRUZXh0XG4gICAgICB7ZGVzY3JpcHRpb25JZH1cbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG5cbiAgeyNpZiBBcnJheS5pc0FycmF5KHN0ZXAub3B0aW9ucy5idXR0b25zKSAmJiBzdGVwLm9wdGlvbnMuYnV0dG9ucy5sZW5ndGh9XG4gICAgPFNoZXBoZXJkRm9vdGVyXG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50LCBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZENvbnRlbnQgZnJvbSAnLi9zaGVwaGVyZC1jb250ZW50LnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuXG4gIGNvbnN0IEtFWV9UQUIgPSA5O1xuICBjb25zdCBLRVlfRVNDID0gMjc7XG4gIGNvbnN0IExFRlRfQVJST1cgPSAzNztcbiAgY29uc3QgUklHSFRfQVJST1cgPSAzOTtcblxuICBleHBvcnQgbGV0IGNsYXNzUHJlZml4LCBlbGVtZW50LCBkZXNjcmlwdGlvbklkLCBmaXJzdEZvY3VzYWJsZUVsZW1lbnQsXG4gICAgZm9jdXNhYmxlRWxlbWVudHMsIGxhYmVsSWQsIGxhc3RGb2N1c2FibGVFbGVtZW50LCBzdGVwLCBkYXRhU3RlcElkO1xuXG4gIGxldCBoYXNDYW5jZWxJY29uLCBoYXNUaXRsZSwgY2xhc3NlcztcblxuICAkOiB7XG4gICAgaGFzQ2FuY2VsSWNvbiA9IHN0ZXAub3B0aW9ucyAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbiAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkO1xuICAgIGhhc1RpdGxlID0gc3RlcC5vcHRpb25zICYmIHN0ZXAub3B0aW9ucy50aXRsZTtcbiAgfVxuXG4gIGV4cG9ydCBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcblxuICBvbk1vdW50KCgpID0+IHtcbiAgICAvLyBHZXQgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGZvY3VzYWJsZVxuICAgIGRhdGFTdGVwSWQgPSB7IFtgZGF0YS0ke2NsYXNzUHJlZml4fXNoZXBoZXJkLXN0ZXAtaWRgXTogc3RlcC5pZCB9O1xuICAgIGZvY3VzYWJsZUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgW3RhYmluZGV4PVwiMFwiXScpO1xuICAgIGZpcnN0Rm9jdXNhYmxlRWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzWzBdO1xuICAgIGxhc3RGb2N1c2FibGVFbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZihjbGFzc2VzICE9PSBzdGVwLm9wdGlvbnMuY2xhc3Nlcykge1xuICAgICAgdXBkYXRlRHluYW1pY0NsYXNzZXMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNDbGFzc2VzKCkge1xuICAgICAgcmVtb3ZlQ2xhc3NlcyhjbGFzc2VzKTtcbiAgICAgIGNsYXNzZXMgPSBzdGVwLm9wdGlvbnMuY2xhc3NlcztcbiAgICAgIGFkZENsYXNzZXMoY2xhc3Nlcyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICBpZiAoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IG9sZENsYXNzZXMgPSBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gICAgICBpZiAob2xkQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLm9sZENsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzZXMoY2xhc3Nlcykge1xuICAgIGlmKGlzU3RyaW5nKGNsYXNzZXMpKSB7XG4gICAgICBjb25zdCBuZXdDbGFzc2VzID0gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICAgICAgaWYgKG5ld0NsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5uZXdDbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcykge1xuICAgICByZXR1cm4gY2xhc3Nlcy5zcGxpdCgnICcpLmZpbHRlcihjbGFzc05hbWUgPT4gISFjbGFzc05hbWUubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBrZXlkb3duIGV2ZW50cyB0byBhbGxvdyBjbG9zaW5nIHRoZSBtb2RhbCB3aXRoIEVTQ1xuICAgKlxuICAgKiBCb3Jyb3dlZCBmcm9tIHRoaXMgZ3JlYXQgcG9zdCEgaHR0cHM6Ly9iaXRzb2Zjby5kZS9hY2Nlc3NpYmxlLW1vZGFsLWRpYWxvZy9cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZSkgPT4ge1xuICAgIGNvbnN0IHsgdG91ciB9ID0gc3RlcDtcbiAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgY2FzZSBLRVlfVEFCOlxuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhY2t3YXJkIHRhYlxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmaXJzdEZvY3VzYWJsZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3NoZXBoZXJkLWVsZW1lbnQnKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbGFzdEZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RGb2N1c2FibGVFbGVtZW50KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBmaXJzdEZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWV9FU0M6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMuZXhpdE9uRXNjKSB7XG4gICAgICAgICAgc3RlcC5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICB0b3VyLmJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgdG91ci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWVsZW1lbnQge1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIGJveC1zaGFkb3c6IDAgMXB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMik7XG4gICAgbWF4LXdpZHRoOiA0MDBweDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzLCB2aXNpYmlsaXR5IDAuM3M7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHotaW5kZXg6IDk5OTk7XG4gIH1cblxuICAuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC1lbGVtZW50IHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuXTpub3QoLnNoZXBoZXJkLWNlbnRlcmVkKSB7XG4gICAgb3BhY2l0eTogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudCwgLnNoZXBoZXJkLWVsZW1lbnQgKixcbiAgLnNoZXBoZXJkLWVsZW1lbnQgKjphZnRlcixcbiAgLnNoZXBoZXJkLWVsZW1lbnQgKjpiZWZvcmUge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cblxuICAuc2hlcGhlcmQtYXJyb3csXG4gIC5zaGVwaGVyZC1hcnJvdzo6YmVmb3JlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDE2cHg7XG4gICAgaGVpZ2h0OiAxNnB4O1xuICAgIHotaW5kZXg6IC0xO1xuICB9XG5cbiAgLnNoZXBoZXJkLWFycm93OmJlZm9yZSB7XG4gICAgY29udGVudDogJyc7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xuICAgIGJhY2tncm91bmQ6ICNmZmYgIDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J3RvcCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBib3R0b206IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdib3R0b20nXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgdG9wOiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nbGVmdCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICByaWdodDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J3JpZ2h0J10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIGxlZnQ6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudC5zaGVwaGVyZC1jZW50ZXJlZCA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxuXG5cbiAgLyoqXG4gICogQXJyb3cgb24gdG9wIG9mIHRvb2x0aXAgY2VudGVyZWQgaG9yaXpvbnRhbGx5LCB3aXRoIHRpdGxlIGNvbG9yXG4gICovXG4gIC5zaGVwaGVyZC1lbGVtZW50LnNoZXBoZXJkLWhhcy10aXRsZVtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdib3R0b20nXSA+IC5zaGVwaGVyZC1hcnJvdzo6YmVmb3JlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2O1xuICB9XG5cbiAgLnNoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLXRhcmdldCxcbiAgLnNoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLXRhcmdldCAqIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBhcmlhLWRlc2NyaWJlZGJ5PXshaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRleHQpID8gZGVzY3JpcHRpb25JZCA6IG51bGx9XG4gIGFyaWEtbGFiZWxsZWRieT17c3RlcC5vcHRpb25zLnRpdGxlID8gbGFiZWxJZCA6IG51bGx9XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M6c2hlcGhlcmQtaGFzLWNhbmNlbC1pY29uPVwie2hhc0NhbmNlbEljb259XCJcbiAgY2xhc3M6c2hlcGhlcmQtaGFzLXRpdGxlPVwie2hhc1RpdGxlfVwiXG4gIGNsYXNzOnNoZXBoZXJkLWVsZW1lbnQ9XCJ7dHJ1ZX1cIlxuICB7Li4uZGF0YVN0ZXBJZH1cbiAgb246a2V5ZG93bj17aGFuZGxlS2V5RG93bn1cbiAgcm9sZT1cImRpYWxvZ1wiXG4gIHRhYmluZGV4PVwiMFwiXG4+XG4gICAgeyNpZiBzdGVwLm9wdGlvbnMuYXJyb3cgJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUby5lbGVtZW50ICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUby5vbn1cbiAgICAgIDxkaXYgY2xhc3M9XCJzaGVwaGVyZC1hcnJvd1wiIGRhdGEtcG9wcGVyLWFycm93PjwvZGl2PlxuICAgIHsvaWZ9XG4gIDxTaGVwaGVyZENvbnRlbnRcbiAgICB7ZGVzY3JpcHRpb25JZH1cbiAgICB7bGFiZWxJZH1cbiAgICB7c3RlcH1cbiAgLz5cbjwvZGl2PlxuIiwiLyogc21vb3Roc2Nyb2xsIHYwLjQuNCAtIDIwMTkgLSBEdXN0YW4gS2FzdGVuLCBKZXJlbWlhcyBNZW5pY2hlbGxpIC0gTUlUIExpY2Vuc2UgKi9cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBwb2x5ZmlsbFxuICBmdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgICAvLyBhbGlhc2VzXG4gICAgdmFyIHcgPSB3aW5kb3c7XG4gICAgdmFyIGQgPSBkb2N1bWVudDtcblxuICAgIC8vIHJldHVybiBpZiBzY3JvbGwgYmVoYXZpb3IgaXMgc3VwcG9ydGVkIGFuZCBwb2x5ZmlsbCBpcyBub3QgZm9yY2VkXG4gICAgaWYgKFxuICAgICAgJ3Njcm9sbEJlaGF2aW9yJyBpbiBkLmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJlxuICAgICAgdy5fX2ZvcmNlU21vb3RoU2Nyb2xsUG9seWZpbGxfXyAhPT0gdHJ1ZVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdsb2JhbHNcbiAgICB2YXIgRWxlbWVudCA9IHcuSFRNTEVsZW1lbnQgfHwgdy5FbGVtZW50O1xuICAgIHZhciBTQ1JPTExfVElNRSA9IDQ2ODtcblxuICAgIC8vIG9iamVjdCBnYXRoZXJpbmcgb3JpZ2luYWwgc2Nyb2xsIG1ldGhvZHNcbiAgICB2YXIgb3JpZ2luYWwgPSB7XG4gICAgICBzY3JvbGw6IHcuc2Nyb2xsIHx8IHcuc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxCeTogdy5zY3JvbGxCeSxcbiAgICAgIGVsZW1lbnRTY3JvbGw6IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCB8fCBzY3JvbGxFbGVtZW50LFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3XG4gICAgfTtcblxuICAgIC8vIGRlZmluZSB0aW1pbmcgbWV0aG9kXG4gICAgdmFyIG5vdyA9XG4gICAgICB3LnBlcmZvcm1hbmNlICYmIHcucGVyZm9ybWFuY2Uubm93XG4gICAgICAgID8gdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3LnBlcmZvcm1hbmNlKVxuICAgICAgICA6IERhdGUubm93O1xuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBtYWRlIGJ5IE1pY3Jvc29mdFxuICAgICAqIEBtZXRob2QgaXNNaWNyb3NvZnRCcm93c2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJBZ2VudFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWljcm9zb2Z0QnJvd3Nlcih1c2VyQWdlbnQpIHtcbiAgICAgIHZhciB1c2VyQWdlbnRQYXR0ZXJucyA9IFsnTVNJRSAnLCAnVHJpZGVudC8nLCAnRWRnZS8nXTtcblxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodXNlckFnZW50UGF0dGVybnMuam9pbignfCcpKS50ZXN0KHVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBJRSBoYXMgcm91bmRpbmcgYnVnIHJvdW5kaW5nIGRvd24gY2xpZW50SGVpZ2h0IGFuZCBjbGllbnRXaWR0aCBhbmRcbiAgICAgKiByb3VuZGluZyB1cCBzY3JvbGxIZWlnaHQgYW5kIHNjcm9sbFdpZHRoIGNhdXNpbmcgZmFsc2UgcG9zaXRpdmVzXG4gICAgICogb24gaGFzU2Nyb2xsYWJsZVNwYWNlXG4gICAgICovXG4gICAgdmFyIFJPVU5ESU5HX1RPTEVSQU5DRSA9IGlzTWljcm9zb2Z0QnJvd3Nlcih3Lm5hdmlnYXRvci51c2VyQWdlbnQpID8gMSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBjaGFuZ2VzIHNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2Qgc2Nyb2xsRWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjcm9sbEVsZW1lbnQoeCwgeSkge1xuICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0geDtcbiAgICAgIHRoaXMuc2Nyb2xsVG9wID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHJlc3VsdCBvZiBhcHBseWluZyBlYXNlIG1hdGggZnVuY3Rpb24gdG8gYSBudW1iZXJcbiAgICAgKiBAbWV0aG9kIGVhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFzZShrKSB7XG4gICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHNtb290aCBiZWhhdmlvciBzaG91bGQgYmUgYXBwbGllZFxuICAgICAqIEBtZXRob2Qgc2hvdWxkQmFpbE91dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZmlyc3RBcmdcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG91bGRCYWlsT3V0KGZpcnN0QXJnKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGZpcnN0QXJnID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBmaXJzdEFyZyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ2F1dG8nIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnaW5zdGFudCdcbiAgICAgICkge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0L251bGxcbiAgICAgICAgLy8gb3IgYmVoYXZpb3IgaXMgYXV0bywgaW5zdGFudCBvciB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmlyc3RBcmcgPT09ICdvYmplY3QnICYmIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3QgYW5kIGJlaGF2aW9yIGlzIHNtb290aFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yIHdoZW4gYmVoYXZpb3IgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2JlaGF2aW9yIG1lbWJlciBvZiBTY3JvbGxPcHRpb25zICcgK1xuICAgICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yICtcbiAgICAgICAgICAnIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBlbnVtZXJhdGlvbiBTY3JvbGxCZWhhdmlvci4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGhhcyBzY3JvbGxhYmxlIHNwYWNlIGluIHRoZSBwcm92aWRlZCBheGlzXG4gICAgICogQG1ldGhvZCBoYXNTY3JvbGxhYmxlU3BhY2VcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsIGF4aXMpIHtcbiAgICAgIGlmIChheGlzID09PSAnWScpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsaWVudEhlaWdodCArIFJPVU5ESU5HX1RPTEVSQU5DRSA8IGVsLnNjcm9sbEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgPT09ICdYJykge1xuICAgICAgICByZXR1cm4gZWwuY2xpZW50V2lkdGggKyBST1VORElOR19UT0xFUkFOQ0UgPCBlbC5zY3JvbGxXaWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBoYXMgYSBzY3JvbGxhYmxlIG92ZXJmbG93IHByb3BlcnR5IGluIHRoZSBheGlzXG4gICAgICogQG1ldGhvZCBjYW5PdmVyZmxvd1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbk92ZXJmbG93KGVsLCBheGlzKSB7XG4gICAgICB2YXIgb3ZlcmZsb3dWYWx1ZSA9IHcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbClbJ292ZXJmbG93JyArIGF4aXNdO1xuXG4gICAgICByZXR1cm4gb3ZlcmZsb3dWYWx1ZSA9PT0gJ2F1dG8nIHx8IG92ZXJmbG93VmFsdWUgPT09ICdzY3JvbGwnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGNhbiBiZSBzY3JvbGxlZCBpbiBlaXRoZXIgYXhpc1xuICAgICAqIEBtZXRob2QgaXNTY3JvbGxhYmxlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsKSB7XG4gICAgICB2YXIgaXNTY3JvbGxhYmxlWSA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1knKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1knKTtcbiAgICAgIHZhciBpc1Njcm9sbGFibGVYID0gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCAnWCcpICYmIGNhbk92ZXJmbG93KGVsLCAnWCcpO1xuXG4gICAgICByZXR1cm4gaXNTY3JvbGxhYmxlWSB8fCBpc1Njcm9sbGFibGVYO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZpbmRzIHNjcm9sbGFibGUgcGFyZW50IG9mIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIGZpbmRTY3JvbGxhYmxlUGFyZW50XG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEByZXR1cm5zIHtOb2RlfSBlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRTY3JvbGxhYmxlUGFyZW50KGVsKSB7XG4gICAgICB3aGlsZSAoZWwgIT09IGQuYm9keSAmJiBpc1Njcm9sbGFibGUoZWwpID09PSBmYWxzZSkge1xuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGUgfHwgZWwuaG9zdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlbGYgaW52b2tlZCBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIGNvbnRleHQsIHN0ZXBzIHRocm91Z2ggc2Nyb2xsaW5nXG4gICAgICogQG1ldGhvZCBzdGVwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0ZXAoY29udGV4dCkge1xuICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBjdXJyZW50WDtcbiAgICAgIHZhciBjdXJyZW50WTtcbiAgICAgIHZhciBlbGFwc2VkID0gKHRpbWUgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBTQ1JPTExfVElNRTtcblxuICAgICAgLy8gYXZvaWQgZWxhcHNlZCB0aW1lcyBoaWdoZXIgdGhhbiBvbmVcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG4gICAgICAvLyBhcHBseSBlYXNpbmcgdG8gZWxhcHNlZCB0aW1lXG4gICAgICB2YWx1ZSA9IGVhc2UoZWxhcHNlZCk7XG5cbiAgICAgIGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XG4gICAgICBjdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuXG4gICAgICBjb250ZXh0Lm1ldGhvZC5jYWxsKGNvbnRleHQuc2Nyb2xsYWJsZSwgY3VycmVudFgsIGN1cnJlbnRZKTtcblxuICAgICAgLy8gc2Nyb2xsIG1vcmUgaWYgd2UgaGF2ZSBub3QgcmVhY2hlZCBvdXIgZGVzdGluYXRpb25cbiAgICAgIGlmIChjdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGN1cnJlbnRZICE9PSBjb250ZXh0LnkpIHtcbiAgICAgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcC5iaW5kKHcsIGNvbnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzY3JvbGxzIHdpbmRvdyBvciBlbGVtZW50IHdpdGggYSBzbW9vdGggYmVoYXZpb3JcbiAgICAgKiBAbWV0aG9kIHNtb290aFNjcm9sbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fE5vZGV9IGVsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc21vb3RoU2Nyb2xsKGVsLCB4LCB5KSB7XG4gICAgICB2YXIgc2Nyb2xsYWJsZTtcbiAgICAgIHZhciBzdGFydFg7XG4gICAgICB2YXIgc3RhcnRZO1xuICAgICAgdmFyIG1ldGhvZDtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBub3coKTtcblxuICAgICAgLy8gZGVmaW5lIHNjcm9sbCBjb250ZXh0XG4gICAgICBpZiAoZWwgPT09IGQuYm9keSkge1xuICAgICAgICBzY3JvbGxhYmxlID0gdztcbiAgICAgICAgc3RhcnRYID0gdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQ7XG4gICAgICAgIHN0YXJ0WSA9IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0O1xuICAgICAgICBtZXRob2QgPSBvcmlnaW5hbC5zY3JvbGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxhYmxlID0gZWw7XG4gICAgICAgIHN0YXJ0WCA9IGVsLnNjcm9sbExlZnQ7XG4gICAgICAgIHN0YXJ0WSA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgbWV0aG9kID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gc2Nyb2xsIGxvb3Bpbmcgb3ZlciBhIGZyYW1lXG4gICAgICBzdGVwKHtcbiAgICAgICAgc2Nyb2xsYWJsZTogc2Nyb2xsYWJsZSxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgICBzdGFydFg6IHN0YXJ0WCxcbiAgICAgICAgc3RhcnRZOiBzdGFydFksXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE9SSUdJTkFMIE1FVEhPRFMgT1ZFUlJJREVTXG4gICAgLy8gdy5zY3JvbGwgYW5kIHcuc2Nyb2xsVG9cbiAgICB3LnNjcm9sbCA9IHcuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbC5jYWxsKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICA/IGFyZ3VtZW50c1swXVxuICAgICAgICAgICAgICA6IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgIC8vIHVzZSB0b3AgcHJvcCwgc2Vjb25kIGFyZ3VtZW50IGlmIHByZXNlbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsWVxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gYXJndW1lbnRzWzFdXG4gICAgICAgICAgICAgIDogdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXRcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICA6IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0LFxuICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgIDogdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXRcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHcuc2Nyb2xsQnlcbiAgICB3LnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGxCeS5jYWxsKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JyA/IGFyZ3VtZW50c1swXSA6IDAsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgKHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0KSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0udG9wICsgKHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIGFuZCBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUb1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCA9IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBpZiBvbmUgbnVtYmVyIGlzIHBhc3NlZCwgdGhyb3cgZXJyb3IgdG8gbWF0Y2ggRmlyZWZveCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1ZhbHVlIGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9yaWdpbmFsLmVsZW1lbnRTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIC8vIHVzZSBsZWZ0IHByb3AsIGZpcnN0IG51bWJlciBhcmd1bWVudCBvciBmYWxsYmFjayB0byBzY3JvbGxMZWZ0XG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnID8gfn5hcmd1bWVudHNbMF0gOiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgLy8gdXNlIHRvcCBwcm9wLCBzZWNvbmQgYXJndW1lbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsVG9wXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IH5+YXJndW1lbnRzWzFdIDogdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gYXJndW1lbnRzWzBdLmxlZnQ7XG4gICAgICB2YXIgdG9wID0gYXJndW1lbnRzWzBdLnRvcDtcblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2Nyb2xsTGVmdCA6IH5+bGVmdCxcbiAgICAgICAgdHlwZW9mIHRvcCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNjcm9sbFRvcCA6IH5+dG9wXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeVxuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5lbGVtZW50U2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnRcbiAgICAgICAgICAgIDogfn5hcmd1bWVudHNbMF0gKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLnRvcCArIHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICAgICA6IH5+YXJndW1lbnRzWzFdICsgdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsKHtcbiAgICAgICAgbGVmdDogfn5hcmd1bWVudHNbMF0ubGVmdCArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgdG9wOiB+fmFyZ3VtZW50c1swXS50b3AgKyB0aGlzLnNjcm9sbFRvcCxcbiAgICAgICAgYmVoYXZpb3I6IGFyZ3VtZW50c1swXS5iZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsSW50b1ZpZXcuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgdmFyIHNjcm9sbGFibGVQYXJlbnQgPSBmaW5kU2Nyb2xsYWJsZVBhcmVudCh0aGlzKTtcbiAgICAgIHZhciBwYXJlbnRSZWN0cyA9IHNjcm9sbGFibGVQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY2xpZW50UmVjdHMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAoc2Nyb2xsYWJsZVBhcmVudCAhPT0gZC5ib2R5KSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluc2lkZSBwYXJlbnRcbiAgICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsTGVmdCArIGNsaWVudFJlY3RzLmxlZnQgLSBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsVG9wICsgY2xpZW50UmVjdHMudG9wIC0gcGFyZW50UmVjdHMudG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcmV2ZWFsIHBhcmVudCBpbiB2aWV3cG9ydCB1bmxlc3MgaXMgZml4ZWRcbiAgICAgICAgaWYgKHcuZ2V0Q29tcHV0ZWRTdHlsZShzY3JvbGxhYmxlUGFyZW50KS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgICAgbGVmdDogcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICAgIHRvcDogcGFyZW50UmVjdHMudG9wLFxuICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJldmVhbCBlbGVtZW50IGluIHZpZXdwb3J0XG4gICAgICAgIHcuc2Nyb2xsQnkoe1xuICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgdG9wOiBjbGllbnRSZWN0cy50b3AsXG4gICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gY29tbW9uanNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsgcG9seWZpbGw6IHBvbHlmaWxsIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2xvYmFsXG4gICAgcG9seWZpbGwoKTtcbiAgfVxuXG59KCkpO1xuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5pbXBvcnQgeyBFdmVudGVkIH0gZnJvbSAnLi9ldmVudGVkLmpzJztcbmltcG9ydCBhdXRvQmluZCBmcm9tICcuL3V0aWxzL2F1dG8tYmluZC5qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrLmpzJztcbmltcG9ydCB7IGJpbmRBZHZhbmNlIH0gZnJvbSAnLi91dGlscy9iaW5kLmpzJztcbmltcG9ydCB7XG4gIHNldHVwVG9vbHRpcCxcbiAgcGFyc2VBdHRhY2hUbyxcbiAgbm9ybWFsaXplUHJlZml4LFxuICB1dWlkXG59IGZyb20gJy4vdXRpbHMvZ2VuZXJhbC5qcyc7XG5pbXBvcnQgU2hlcGhlcmRFbGVtZW50IGZyb20gJy4vY29tcG9uZW50cy9zaGVwaGVyZC1lbGVtZW50LnN2ZWx0ZSc7XG5cbi8vIFBvbHlmaWxsc1xuaW1wb3J0IHNtb290aHNjcm9sbCBmcm9tICdzbW9vdGhzY3JvbGwtcG9seWZpbGwnO1xuc21vb3Roc2Nyb2xsLnBvbHlmaWxsKCk7XG5cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgc3RlcHMgdG8gYmUgYWRkZWQgdG8gYSB0b3VyLlxuICogQGV4dGVuZHMge0V2ZW50ZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBTdGVwIGV4dGVuZHMgRXZlbnRlZCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdGVwXG4gICAqIEBwYXJhbSB7VG91cn0gdG91ciBUaGUgdG91ciBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5hcnJvdyBXaGV0aGVyIHRvIGRpc3BsYXkgdGhlIGFycm93IGZvciB0aGUgdG9vbHRpcCBvciBub3QuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYXR0YWNoVG8gVGhlIGVsZW1lbnQgdGhlIHN0ZXAgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIG9uIHRoZSBwYWdlLlxuICAgKiBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGBlbGVtZW50YCBhbmQgYG9uYC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RlcCA9IG5ldyBTdGVwKHRvdXIsIHtcbiAgICogICBhdHRhY2hUbzogeyBlbGVtZW50OiAnLnNvbWUgLnNlbGVjdG9yLXBhdGgnLCBvbjogJ2xlZnQnIH0sXG4gICAqICAgLi4ubW9yZU9wdGlvbnNcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3UgZG9u4oCZdCBzcGVjaWZ5IGFuIGF0dGFjaFRvIHRoZSBlbGVtZW50IHdpbGwgYXBwZWFyIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi5cbiAgICogSWYgeW91IG9taXQgdGhlIGBvbmAgcG9ydGlvbiBvZiBgYXR0YWNoVG9gLCB0aGUgZWxlbWVudCB3aWxsIHN0aWxsIGJlIGhpZ2hsaWdodGVkLCBidXQgdGhlIHRvb2x0aXAgd2lsbCBhcHBlYXJcbiAgICogaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLCB3aXRob3V0IGFuIGFycm93IHBvaW50aW5nIHRvIHRoZSB0YXJnZXQuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBvcHRpb25zLmF0dGFjaFRvLmVsZW1lbnQgQW4gZWxlbWVudCBzZWxlY3RvciBzdHJpbmcgb3IgYSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYXR0YWNoVG8ub24gVGhlIG9wdGlvbmFsIGRpcmVjdGlvbiB0byBwbGFjZSB0aGUgUG9wcGVyIHRvb2x0aXAgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQuXG4gICAqICAgLSBQb3NzaWJsZSBzdHJpbmcgdmFsdWVzOiAnYXV0bycsICdhdXRvLXN0YXJ0JywgJ2F1dG8tZW5kJywgJ3RvcCcsICd0b3Atc3RhcnQnLCAndG9wLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnLCAncmlnaHQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCcsICdsZWZ0LWVuZCdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYWR2YW5jZU9uIEFuIGFjdGlvbiBvbiB0aGUgcGFnZSB3aGljaCBzaG91bGQgYWR2YW5jZSBzaGVwaGVyZCB0byB0aGUgbmV4dCBzdGVwLlxuICAgKiBJdCBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggYSBzdHJpbmcgYHNlbGVjdG9yYCBhbmQgYW4gYGV2ZW50YCBuYW1lXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0ZXAgPSBuZXcgU3RlcCh0b3VyLCB7XG4gICAqICAgYWR2YW5jZU9uOiB7IHNlbGVjdG9yOiAnLnNvbWUgLnNlbGVjdG9yLXBhdGgnLCBldmVudDogJ2NsaWNrJyB9LFxuICAgKiAgIC4uLm1vcmVPcHRpb25zXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogYGV2ZW50YCBkb2VzbuKAmXQgaGF2ZSB0byBiZSBhbiBldmVudCBpbnNpZGUgdGhlIHRvdXIsIGl0IGNhbiBiZSBhbnkgZXZlbnQgZmlyZWQgb24gYW55IGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gICAqIFlvdSBjYW4gYWxzbyBhbHdheXMgbWFudWFsbHkgYWR2YW5jZSB0aGUgVG91ciBieSBjYWxsaW5nIGBteVRvdXIubmV4dCgpYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gICAqIFdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHRoZSByZXN0IG9mIHRoZSBgc2hvd2AgY29kZSBmb3IgdGhlIHN0ZXAgd2lsbCBleGVjdXRlLlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBvcHRpb25zLmJ1dHRvbnMgQW4gYXJyYXkgb2YgYnV0dG9ucyB0byBhZGQgdG8gdGhlIHN0ZXAuIFRoZXNlIHdpbGwgYmUgcmVuZGVyZWQgaW4gYVxuICAgKiBmb290ZXIgYmVsb3cgdGhlIG1haW4gYm9keSB0ZXh0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmFjdGlvbiBBIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIG9uLlxuICAgKiBJdCBpcyBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZSBgdG91cmAgdGhlIHN0ZXAgaXMgYXNzb2NpYXRlZCB3aXRoLCBzbyB0aGluZ3MgbGlrZSBgdGhpcy5uZXh0YCB3aWxsXG4gICAqIHdvcmsgaW5zaWRlIHRoZSBhY3Rpb24uXG4gICAqIFlvdSBjYW4gdXNlIGFjdGlvbiB0byBza2lwIHN0ZXBzIG9yIG5hdmlnYXRlIHRvIHNwZWNpZmljIHN0ZXBzLCB3aXRoIHNvbWV0aGluZyBsaWtlOlxuICAgKiBgYGBqc1xuICAgKiBhY3Rpb24oKSB7XG4gICAqICAgcmV0dXJuIHRoaXMuc2hvdygnc29tZV9zdGVwX25hbWUnKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uY2xhc3NlcyBFeHRyYSBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBgPGE+YFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uZGlzYWJsZWQgU2hvdWxkIHRoZSBidXR0b24gYmUgZGlzYWJsZWQ/XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmxhYmVsIFRoZSBhcmlhLWxhYmVsIHRleHQgb2YgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uc2Vjb25kYXJ5IElmIHRydWUsIGEgc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeSBjbGFzcyBpcyBhcHBsaWVkIHRvIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24udGV4dCBUaGUgSFRNTCB0ZXh0IG9mIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNhbkNsaWNrVGFyZ2V0IEEgYm9vbGVhbiwgdGhhdCB3aGVuIHNldCB0byBmYWxzZSwgd2lsbCBzZXQgYHBvaW50ZXItZXZlbnRzOiBub25lYCBvbiB0aGUgdGFyZ2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNhbmNlbEljb24gT3B0aW9ucyBmb3IgdGhlIGNhbmNlbCBpY29uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQgU2hvdWxkIGEgY2FuY2VsIOKAnOKcleKAnSBiZSBzaG93biBpbiB0aGUgaGVhZGVyIG9mIHRoZSBzdGVwP1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYW5jZWxJY29uLmxhYmVsIFRoZSBsYWJlbCB0byBhZGQgZm9yIGBhcmlhLWxhYmVsYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbGFzc2VzIEEgc3RyaW5nIG9mIGV4dHJhIGNsYXNzZXMgdG8gYWRkIHRvIHRoZSBzdGVwJ3MgY29udGVudCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5oaWdobGlnaHRDbGFzcyBBbiBleHRyYSBjbGFzcyB0byBhcHBseSB0byB0aGUgYGF0dGFjaFRvYCBlbGVtZW50IHdoZW4gaXQgaXNcbiAgICogaGlnaGxpZ2h0ZWQgKHRoYXQgaXMsIHdoZW4gaXRzIHN0ZXAgaXMgYWN0aXZlKS4gWW91IGNhbiB0aGVuIHRhcmdldCB0aGF0IHNlbGVjdG9yIGluIHlvdXIgQ1NTLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5pZCBUaGUgc3RyaW5nIHRvIHVzZSBhcyB0aGUgYGlkYCBmb3IgdGhlIHN0ZXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIEFuIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIEFuIGFtb3VudCBvZiBib3JkZXIgcmFkaXVzIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5wb3BwZXJPcHRpb25zIEV4dHJhIG9wdGlvbnMgdG8gcGFzcyB0byBQb3BwZXJcbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gb3B0aW9ucy5zY3JvbGxUbyBTaG91bGQgdGhlIGVsZW1lbnQgYmUgc2Nyb2xsZWQgdG8gd2hlbiB0aGlzIHN0ZXAgaXMgc2hvd24/IElmIHRydWUsIHVzZXMgdGhlIGRlZmF1bHQgYHNjcm9sbEludG9WaWV3YCxcbiAgICogaWYgYW4gb2JqZWN0LCBwYXNzZXMgdGhhdCBvYmplY3QgYXMgdGhlIHBhcmFtcyB0byBgc2Nyb2xsSW50b1ZpZXdgIGkuZS4gYHtiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJ31gXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyIEEgZnVuY3Rpb24gdGhhdCBsZXRzIHlvdSBvdmVycmlkZSB0aGUgZGVmYXVsdCBzY3JvbGxUbyBiZWhhdmlvciBhbmRcbiAgICogZGVmaW5lIGEgY3VzdG9tIGFjdGlvbiB0byBkbyB0aGUgc2Nyb2xsaW5nLCBhbmQgcG9zc2libHkgb3RoZXIgbG9naWMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuc2hvd09uIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBpdCByZXR1cm5zIGB0cnVlYCwgd2lsbCBzaG93IHRoZSBzdGVwLlxuICAgKiBJZiBpdCByZXR1cm5zIGZhbHNlLCB0aGUgc3RlcCB3aWxsIGJlIHNraXBwZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRleHQgVGhlIHRleHQgaW4gdGhlIGJvZHkgb2YgdGhlIHN0ZXAuIEl0IGNhbiBiZSBvbmUgb2YgdGhyZWUgdHlwZXM6XG4gICAqIGBgYFxuICAgKiAtIEhUTUwgc3RyaW5nXG4gICAqIC0gYEhUTUxFbGVtZW50YCBvYmplY3RcbiAgICogLSBgRnVuY3Rpb25gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHN0ZXAgaXMgYnVpbHQuIEl0IG11c3QgcmV0dXJuIG9uZSB0aGUgdHdvIG9wdGlvbnMgYWJvdmUuXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aXRsZSBUaGUgc3RlcCdzIHRpdGxlLiBJdCBiZWNvbWVzIGFuIGBoM2AgYXQgdGhlIHRvcCBvZiB0aGUgc3RlcC4gSXQgY2FuIGJlIG9uZSBvZiB0d28gdHlwZXM6XG4gICAqIGBgYFxuICAgKiAtIEhUTUwgc3RyaW5nXG4gICAqIC0gYEZ1bmN0aW9uYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBzdGVwIGlzIGJ1aWx0LiBJdCBtdXN0IHJldHVybiBIVE1MIHN0cmluZy5cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLndoZW4gWW91IGNhbiBkZWZpbmUgYHNob3dgLCBgaGlkZWAsIGV0YyBldmVudHMgaW5zaWRlIGB3aGVuYC4gRm9yIGV4YW1wbGU6XG4gICAqIGBgYGpzXG4gICAqIHdoZW46IHtcbiAgICogICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICogICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBuZXdseSBjcmVhdGVkIFN0ZXAgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvdXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHRvdXIsIG9wdGlvbnMpO1xuICAgIHRoaXMudG91ciA9IHRvdXI7XG4gICAgdGhpcy5jbGFzc1ByZWZpeCA9IHRoaXMudG91ci5vcHRpb25zXG4gICAgICA/IG5vcm1hbGl6ZVByZWZpeCh0aGlzLnRvdXIub3B0aW9ucy5jbGFzc1ByZWZpeClcbiAgICAgIDogJyc7XG4gICAgdGhpcy5zdHlsZXMgPSB0b3VyLnN0eWxlcztcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgdG91clxuICAgKiBUcmlnZ2VycyB0aGUgYGNhbmNlbGAgZXZlbnRcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLnRvdXIuY2FuY2VsKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdjYW5jZWwnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSB0aGUgdG91clxuICAgKiBUcmlnZ2VycyB0aGUgYGNvbXBsZXRlYCBldmVudFxuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy50b3VyLmNvbXBsZXRlKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgc3RlcCwgZGVsZXRlIHRoZSBzdGVwJ3MgZWxlbWVudCwgYW5kIGRlc3Ryb3kgdGhlIFBvcHBlciBpbnN0YW5jZSBmb3IgdGhlIHN0ZXAuXG4gICAqIFRyaWdnZXJzIGBkZXN0cm95YCBldmVudFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50b29sdGlwKSB7XG4gICAgICB0aGlzLnRvb2x0aXAuZGVzdHJveSgpO1xuICAgICAgdGhpcy50b29sdGlwID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0aGlzLmVsKSAmJiB0aGlzLmVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvdXIgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge1RvdXJ9IFRoZSB0b3VyIGluc3RhbmNlXG4gICAqL1xuICBnZXRUb3VyKCkge1xuICAgIHJldHVybiB0aGlzLnRvdXI7XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgc3RlcFxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRvdXIubW9kYWwuaGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmUtaGlkZScpO1xuXG4gICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2hpZGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHN0ZXAgc2hvdWxkIGJlIGNlbnRlcmVkIG9yIG5vdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdGVwIGlzIGNlbnRlcmVkXG4gICAqL1xuICBpc0NlbnRlcmVkKCkge1xuICAgIGNvbnN0IGF0dGFjaFRvT3B0aW9ucyA9IHBhcnNlQXR0YWNoVG8odGhpcyk7XG4gICAgcmV0dXJuICFhdHRhY2hUb09wdGlvbnMuZWxlbWVudCB8fCAhYXR0YWNoVG9PcHRpb25zLm9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzdGVwIGlzIG9wZW4gYW5kIHZpc2libGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RlcCBpcyBvcGVuIGFuZCB2aXNpYmxlXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5lbCAmJiAhdGhpcy5lbC5oaWRkZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGBfc2hvd2AgYW5kIGVuc3VyZXMgYGJlZm9yZVNob3dQcm9taXNlYCByZXNvbHZlcyBiZWZvcmUgY2FsbGluZyBzaG93XG4gICAqIEByZXR1cm4geyp8UHJvbWlzZX1cbiAgICovXG4gIHNob3coKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmJlZm9yZVNob3dQcm9taXNlKSkge1xuICAgICAgY29uc3QgYmVmb3JlU2hvd1Byb21pc2UgPSB0aGlzLm9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UoKTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQoYmVmb3JlU2hvd1Byb21pc2UpKSB7XG4gICAgICAgIHJldHVybiBiZWZvcmVTaG93UHJvbWlzZS50aGVuKCgpID0+IHRoaXMuX3Nob3coKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3Nob3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBvcHRpb25zIG9mIHRoZSBzdGVwLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICovXG4gIHVwZGF0ZVN0ZXBPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQpIHtcbiAgICAgIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LiRzZXQoeyBzdGVwOiB0aGlzIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQgaW5zdGFuY2UuIHVuZGVmaW5lZCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzaG93biwgbnVsbCBpZiBpdCBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFyZ2V0IGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQgaW5zdGFuY2UuIHVuZGVmaW5lZCBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzaG93biwgbnVsbCBpZiBxdWVyeSBzdHJpbmcgaGFzIG5vdCBiZWVuIGZvdW5kXG4gICAqL1xuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgU2hlcGhlcmQgZWxlbWVudCBmb3Igc3RlcCBiYXNlZCBvbiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBET00gZWxlbWVudCBmb3IgdGhlIHN0ZXAgdG9vbHRpcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVRvb2x0aXBDb250ZW50KCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uSWQgPSBgJHt0aGlzLmlkfS1kZXNjcmlwdGlvbmA7XG4gICAgY29uc3QgbGFiZWxJZCA9IGAke3RoaXMuaWR9LWxhYmVsYDtcblxuICAgIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50ID0gbmV3IFNoZXBoZXJkRWxlbWVudCh7XG4gICAgICB0YXJnZXQ6IHRoaXMudG91ci5vcHRpb25zLnN0ZXBzQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbGFzc1ByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCxcbiAgICAgICAgZGVzY3JpcHRpb25JZCxcbiAgICAgICAgbGFiZWxJZCxcbiAgICAgICAgc3RlcDogdGhpcyxcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIGN1c3RvbSBzY3JvbGxUb0hhbmRsZXIgaXMgZGVmaW5lZCwgY2FsbCB0aGF0LCBvdGhlcndpc2UgZG8gdGhlIGdlbmVyaWNcbiAgICogc2Nyb2xsSW50b1ZpZXcgY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdH0gc2Nyb2xsVG9PcHRpb25zIElmIHRydWUsIHVzZXMgdGhlIGRlZmF1bHQgYHNjcm9sbEludG9WaWV3YCxcbiAgICogaWYgYW4gb2JqZWN0LCBwYXNzZXMgdGhhdCBvYmplY3QgYXMgdGhlIHBhcmFtcyB0byBgc2Nyb2xsSW50b1ZpZXdgIGkuZS4gYHsgYmVoYXZpb3I6ICdzbW9vdGgnLCBibG9jazogJ2NlbnRlcicgfWBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zY3JvbGxUbyhzY3JvbGxUb09wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHBhcnNlQXR0YWNoVG8odGhpcyk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyKSkge1xuICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbFRvSGFuZGxlcihlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNFbGVtZW50KGVsZW1lbnQpICYmXG4gICAgICB0eXBlb2YgZWxlbWVudC5zY3JvbGxJbnRvVmlldyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZWxlbWVudC5zY3JvbGxJbnRvVmlldyhzY3JvbGxUb09wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBfZ2V0Q2xhc3NPcHRpb25zIGdldHMgYWxsIHBvc3NpYmxlIGNsYXNzZXMgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGVwT3B0aW9ucyBUaGUgc3RlcCBzcGVjaWZpYyBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHVuaXF1ZSBzdHJpbmcgZnJvbSBhcnJheSBvZiBjbGFzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Q2xhc3NPcHRpb25zKHN0ZXBPcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zID1cbiAgICAgIHRoaXMudG91ciAmJiB0aGlzLnRvdXIub3B0aW9ucyAmJiB0aGlzLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG4gICAgY29uc3Qgc3RlcENsYXNzZXMgPSBzdGVwT3B0aW9ucy5jbGFzc2VzID8gc3RlcE9wdGlvbnMuY2xhc3NlcyA6ICcnO1xuICAgIGNvbnN0IGRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMgPVxuICAgICAgZGVmYXVsdFN0ZXBPcHRpb25zICYmIGRlZmF1bHRTdGVwT3B0aW9ucy5jbGFzc2VzXG4gICAgICAgID8gZGVmYXVsdFN0ZXBPcHRpb25zLmNsYXNzZXNcbiAgICAgICAgOiAnJztcbiAgICBjb25zdCBhbGxDbGFzc2VzID0gW1xuICAgICAgLi4uc3RlcENsYXNzZXMuc3BsaXQoJyAnKSxcbiAgICAgIC4uLmRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMuc3BsaXQoJyAnKVxuICAgIF07XG4gICAgY29uc3QgdW5pcUNsYXNzZXMgPSBuZXcgU2V0KGFsbENsYXNzZXMpO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20odW5pcUNsYXNzZXMpLmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXAsIG1hcHMgYHdoZW5gIHRvIGV2ZW50cywgc2V0cyB1cCBidXR0b25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHRvdXJPcHRpb25zID1cbiAgICAgIHRoaXMudG91ciAmJiB0aGlzLnRvdXIub3B0aW9ucyAmJiB0aGlzLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG5cbiAgICB0b3VyT3B0aW9ucyA9IG1lcmdlKHt9LCB0b3VyT3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBhcnJvdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRvdXJPcHRpb25zLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICBjb25zdCB7IHdoZW4gfSA9IHRoaXMub3B0aW9ucztcblxuICAgIHRoaXMub3B0aW9ucy5jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZCB8fCBgc3RlcC0ke3V1aWQoKX1gO1xuXG4gICAgaWYgKHdoZW4pIHtcbiAgICAgIE9iamVjdC5rZXlzKHdoZW4pLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMub24oZXZlbnQsIHdoZW5bZXZlbnRdLCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGVsZW1lbnQgYW5kIHNldCB1cCB0aGUgUG9wcGVyIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBFbGVtZW50cygpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuZWwpKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsID0gdGhpcy5fY3JlYXRlVG9vbHRpcENvbnRlbnQoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWR2YW5jZU9uKSB7XG4gICAgICBiaW5kQWR2YW5jZSh0aGlzKTtcbiAgICB9XG4gICAgc2V0dXBUb29sdGlwKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGBiZWZvcmUtc2hvd2AsIGdlbmVyYXRlcyB0aGUgdG9vbHRpcCBET00gY29udGVudCxcbiAgICogc2V0cyB1cCBhIFBvcHBlciBpbnN0YW5jZSBmb3IgdGhlIHRvb2x0aXAsIHRoZW4gdHJpZ2dlcnMgYHNob3dgLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3coKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmUtc2hvdycpO1xuXG4gICAgdGhpcy5fc2V0dXBFbGVtZW50cygpO1xuXG4gICAgaWYgKCF0aGlzLnRvdXIubW9kYWwpIHtcbiAgICAgIHRoaXMudG91ci5fc2V0dXBNb2RhbCgpO1xuICAgIH1cblxuICAgIHRoaXMudG91ci5tb2RhbC5zZXR1cEZvclN0ZXAodGhpcyk7XG4gICAgdGhpcy5fc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcCh0aGlzKTtcbiAgICB0aGlzLmVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgLy8gc3RhcnQgc2Nyb2xsaW5nIHRvIHRhcmdldCBiZWZvcmUgc2hvd2luZyB0aGUgc3RlcFxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsVG8pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLm9wdGlvbnMuc2Nyb2xsVG8pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbC5oaWRkZW4gPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC5nZXRFbGVtZW50KCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLWVuYWJsZWRgKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLXRhcmdldGApO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtZW5hYmxlZCcpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XG4gIH1cblxuICAvKipcbiAgICogTW9kdWxhdGVzIHRoZSBzdHlsZXMgb2YgdGhlIHBhc3NlZCBzdGVwJ3MgdGFyZ2V0IGVsZW1lbnQsIGJhc2VkIG9uIHRoZSBzdGVwJ3Mgb3B0aW9ucyBhbmRcbiAgICogdGhlIHRvdXIncyBgbW9kYWxgIG9wdGlvbiwgdG8gdmlzdWFsbHkgZW1waGFzaXplIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBzdGVwIFRoZSBzdGVwIG9iamVjdCB0aGF0IGF0dGFjaGVzIHRvIHRoZSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcChzdGVwKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHN0ZXAudGFyZ2V0O1xuXG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAub3B0aW9ucy5oaWdobGlnaHRDbGFzcykge1xuICAgICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QuYWRkKHN0ZXAub3B0aW9ucy5oaWdobGlnaHRDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAub3B0aW9ucy5jYW5DbGlja1RhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBzdGVwIGlzIGhpZGRlbiwgcmVtb3ZlIHRoZSBoaWdobGlnaHRDbGFzcyBhbmQgJ3NoZXBoZXJkLWVuYWJsZWQnXG4gICAqIGFuZCAnc2hlcGhlcmQtdGFyZ2V0JyBjbGFzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHRDbGFzcykge1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnLFxuICAgICAgYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC1lbmFibGVkYCxcbiAgICAgIGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YFxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ2xlYW51cCB0aGUgc3RlcHMgYW5kIHNldCBwb2ludGVyRXZlbnRzIGJhY2sgdG8gJ2F1dG8nXG4gKiBAcGFyYW0gdG91ciBUaGUgdG91ciBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBTdGVwcyh0b3VyKSB7XG4gIGlmICh0b3VyKSB7XG4gICAgY29uc3QgeyBzdGVwcyB9ID0gdG91cjtcblxuICAgIHN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgIGlmIChzdGVwLm9wdGlvbnMgJiYgc3RlcC5vcHRpb25zLmNhbkNsaWNrVGFyZ2V0ID09PSBmYWxzZSAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8pIHtcbiAgICAgICAgaWYgKHN0ZXAudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBzdGVwLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEdlbmVyYXRlcyB0aGUgc3ZnIHBhdGggZGF0YSBmb3IgYSByb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5XG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uIC0gRGltZW5zaW9ucyBvZiByZWN0YW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geCBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geSBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3I9MF0gLSBDb3JuZXIgUmFkaXVzLiBLZWVwIHRoaXMgc21hbGxlciB0aGFuICBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUm91bmRlZCByZWN0YW5nbGUgb3ZlcmxheSBwYXRoIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT3ZlcmxheVBhdGgoeyB3aWR0aCwgaGVpZ2h0LCB4ID0gMCwgeSA9IDAsIHIgPSAwIH0pIHtcbiAgY29uc3QgeyBpbm5lcldpZHRoOiB3LCBpbm5lckhlaWdodDogaCB9ID0gd2luZG93O1xuXG4gIHJldHVybiBgTSR7d30sJHtofVxcXG5IMFxcXG5WMFxcXG5IJHt3fVxcXG5WJHtofVxcXG5aXFxcbk0ke3ggKyByfSwke3l9XFxcbmEke3J9LCR7cn0sMCwwLDAtJHtyfSwke3J9XFxcblYke2hlaWdodCArIHkgLSByfVxcXG5hJHtyfSwke3J9LDAsMCwwLCR7cn0sJHtyfVxcXG5IJHt3aWR0aCArIHggLSByfVxcXG5hJHtyfSwke3J9LDAsMCwwLCR7cn0tJHtyfVxcXG5WJHt5ICsgcn1cXFxuYSR7cn0sJHtyfSwwLDAsMC0ke3J9LSR7cn1cXFxuWmA7XG59XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyB1dWlkIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbC5qcyc7XG4gIGltcG9ydCB7IG1ha2VPdmVybGF5UGF0aCB9IGZyb20gJy4uL3V0aWxzL292ZXJsYXktcGF0aC5qcyc7XG5cbiAgZXhwb3J0IGxldCBlbGVtZW50LCBvcGVuaW5nUHJvcGVydGllcztcbiAgY29uc3QgZ3VpZCA9IHV1aWQoKTtcbiAgbGV0IG1vZGFsSXNWaXNpYmxlID0gZmFsc2U7XG4gIGxldCByYWZJZCA9IHVuZGVmaW5lZDtcbiAgbGV0IHBhdGhEZWZpbml0aW9uO1xuXG4gICQ6IHBhdGhEZWZpbml0aW9uID0gbWFrZU92ZXJsYXlQYXRoKG9wZW5pbmdQcm9wZXJ0aWVzKTtcblxuICBjbG9zZU1vZGFsT3BlbmluZygpO1xuXG4gIGV4cG9ydCBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcblxuICBleHBvcnQgZnVuY3Rpb24gY2xvc2VNb2RhbE9wZW5pbmcoKSB7XG4gICAgb3BlbmluZ1Byb3BlcnRpZXMgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgcjogMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcblxuICAgIC8vIEVuc3VyZSB3ZSBjbGVhbnVwIGFsbCBldmVudCBsaXN0ZW5lcnMgd2hlbiB3ZSBoaWRlIHRoZSBtb2RhbFxuICAgIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50IHdlIHdhbnQgdGhlIG9wZW5pbmcgb3ZlcnRvcCBvZiB0byBzZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9wZW5pbmcgYW5kIHBvc2l0aW9uIGl0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyBBbiBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgQW4gYW1vdW50IG9mIGJvcmRlciByYWRpdXMgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNjcm9sbFBhcmVudCBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgdGhlIG9wZW5pbmcgd2lsbCBleHBvc2VcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbk1vZGFsKFxuICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nID0gMCxcbiAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzID0gMCxcbiAgICBzY3JvbGxQYXJlbnQsXG4gICAgdGFyZ2V0RWxlbWVudFxuICApIHtcbiAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgY29uc3QgeyB5LCBoZWlnaHQgfSA9IF9nZXRWaXNpYmxlSGVpZ2h0KHRhcmdldEVsZW1lbnQsIHNjcm9sbFBhcmVudCk7XG4gICAgICBjb25zdCB7IHgsIHdpZHRoLCBsZWZ0IH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgbm90IGNvbnNpc3RlbnQuIFNvbWUgYnJvd3NlcnMgdXNlIHggYW5kIHksIHdoaWxlIG90aGVycyB1c2UgbGVmdCBhbmQgdG9wXG4gICAgICBvcGVuaW5nUHJvcGVydGllcyA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgKiAyLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nICogMixcbiAgICAgICAgeDogKHggfHwgbGVmdCkgLSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgeTogeSAtIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICByOiBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZU1vZGFsT3BlbmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBtb2RhbCBpcyBlbmFibGVkLCBzZXR1cCB0aGUgc3ZnIG1hc2sgb3BlbmluZyBhbmQgbW9kYWwgb3ZlcmxheSBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gc2V0dXBGb3JTdGVwKHN0ZXApIHtcbiAgICAvLyBFbnN1cmUgd2UgbW92ZSBsaXN0ZW5lcnMgZnJvbSB0aGUgcHJldmlvdXMgc3RlcCwgYmVmb3JlIHdlIHNldHVwIG5ldyBvbmVzXG4gICAgX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChzdGVwLnRvdXIub3B0aW9ucy51c2VNb2RhbE92ZXJsYXkpIHtcbiAgICAgIF9zdHlsZUZvclN0ZXAoc3RlcCk7XG4gICAgICBzaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIGNvbnN0IF9wcmV2ZW50TW9kYWxPdmVybGF5VG91Y2ggPSAoZSkgPT4ge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgLy8gUHJldmVudHMgd2luZG93IGZyb20gbW92aW5nIG9uIHRvdWNoLlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AgYW5kIHJlbW92ZSB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAocmFmSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgIHJhZklkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlIHRoZSBtb2RhbCBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIHRvIHN0eWxlIHRoZSBvcGVuaW5nIGZvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3N0eWxlRm9yU3RlcChzdGVwKSB7XG4gICAgY29uc3Qge1xuICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgfSA9IHN0ZXAub3B0aW9ucztcblxuICAgIGNvbnN0IHNjcm9sbFBhcmVudCA9IF9nZXRTY3JvbGxQYXJlbnQoc3RlcC50YXJnZXQpO1xuXG4gICAgLy8gU2V0dXAgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNhbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIHVwZGF0ZSB0aGUgbW9kYWwgb3BlbmluZyBwb3NpdGlvblxuICAgIGNvbnN0IHJhZkxvb3AgPSAoKSA9PiB7XG4gICAgICByYWZJZCA9IHVuZGVmaW5lZDtcbiAgICAgIHBvc2l0aW9uTW9kYWwoXG4gICAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzLFxuICAgICAgICBzY3JvbGxQYXJlbnQsXG4gICAgICAgIHN0ZXAudGFyZ2V0XG4gICAgICApO1xuICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmTG9vcCk7XG4gICAgfTtcblxuICAgIHJhZkxvb3AoKTtcblxuICAgIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBpc0h0bWxFbGVtZW50ID0gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIGNvbnN0IG92ZXJmbG93WSA9XG4gICAgICBpc0h0bWxFbGVtZW50ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLm92ZXJmbG93WTtcbiAgICBjb25zdCBpc1Njcm9sbGFibGUgPSBvdmVyZmxvd1kgIT09ICdoaWRkZW4nICYmIG92ZXJmbG93WSAhPT0gJ3Zpc2libGUnO1xuXG4gICAgaWYgKGlzU2Nyb2xsYWJsZSAmJiBlbGVtZW50LnNjcm9sbEhlaWdodCA+PSBlbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRTY3JvbGxQYXJlbnQoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpc2libGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgc2Nyb2xsUGFyZW50LlxuICAgKiBJZiB0aGVyZSBpcyBubyBzY3JvbGwgcGFyZW50LCB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbc2Nyb2xsUGFyZW50XSBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7e3k6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFZpc2libGVIZWlnaHQoZWxlbWVudCwgc2Nyb2xsUGFyZW50KSB7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB0b3AgPSBlbGVtZW50UmVjdC55IHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICBsZXQgYm90dG9tID0gZWxlbWVudFJlY3QuYm90dG9tIHx8IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodDtcblxuICAgIGlmIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIGNvbnN0IHNjcm9sbFJlY3QgPSBzY3JvbGxQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxSZWN0LnkgfHwgc2Nyb2xsUmVjdC50b3A7XG4gICAgICBjb25zdCBzY3JvbGxCb3R0b20gPSBzY3JvbGxSZWN0LmJvdHRvbSB8fCBzY3JvbGxUb3AgKyBzY3JvbGxSZWN0LmhlaWdodDtcblxuICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBzY3JvbGxUb3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBzY3JvbGxCb3R0b20pO1xuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGJvdHRvbSAtIHRvcCwgMCk7IC8vIERlZmF1bHQgdG8gMCBpZiBoZWlnaHQgaXMgbmVnYXRpdmVcblxuICAgIHJldHVybiB7IHk6IHRvcCwgaGVpZ2h0IH07XG4gIH1cbjwvc2NyaXB0PlxuXG48c3ZnXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M9e2Ake1xuICAgIG1vZGFsSXNWaXNpYmxlID8gJ3NoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUnIDogJydcbiAgfSBzaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcmB9XG4gIG9uOnRvdWNobW92ZT17X3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaH1cbj5cbiAgPHBhdGggZD17cGF0aERlZmluaXRpb259IC8+XG48L3N2Zz5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyIHtcbiAgICBoZWlnaHQ6IDA7XG4gICAgbGVmdDogMDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dCwgaGVpZ2h0IDBtcyAwLjNzLCBvcGFjaXR5IDAuM3MgMG1zO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICB6LWluZGV4OiA5OTk3O1xuICB9XG5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyLnNoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUge1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgb3BhY2l0eTogMC41O1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0LCBoZWlnaHQgMHMgMHMsIG9wYWNpdHkgMC4zcyAwcztcbiAgfVxuXG4gIC5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lci5zaGVwaGVyZC1tb2RhbC1pcy12aXNpYmxlIHBhdGgge1xuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gIH1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgeyBFdmVudGVkIH0gZnJvbSAnLi9ldmVudGVkLmpzJztcbmltcG9ydCB7IFN0ZXAgfSBmcm9tICcuL3N0ZXAuanMnO1xuaW1wb3J0IGF1dG9CaW5kIGZyb20gJy4vdXRpbHMvYXV0by1iaW5kLmpzJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCB9IGZyb20gJy4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5pbXBvcnQgeyBjbGVhbnVwU3RlcHMgfSBmcm9tICcuL3V0aWxzL2NsZWFudXAuanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplUHJlZml4LCB1dWlkIH0gZnJvbSAnLi91dGlscy9nZW5lcmFsLmpzJztcbmltcG9ydCBTaGVwaGVyZE1vZGFsIGZyb20gJy4vY29tcG9uZW50cy9zaGVwaGVyZC1tb2RhbC5zdmVsdGUnO1xuXG5jb25zdCBTaGVwaGVyZCA9IG5ldyBFdmVudGVkKCk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBzaXRlIHRvdXJcbiAqIEBleHRlbmRzIHtFdmVudGVkfVxuICovXG5leHBvcnQgY2xhc3MgVG91ciBleHRlbmRzIEV2ZW50ZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jb25maXJtQ2FuY2VsIElmIHRydWUsIHdpbGwgaXNzdWUgYSBgd2luZG93LmNvbmZpcm1gIGJlZm9yZSBjYW5jZWxsaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNvbmZpcm1DYW5jZWxNZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGRpc3BsYXkgaW4gdGhlIGNvbmZpcm0gZGlhbG9nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsYXNzUHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBgc2hlcGhlcmQtZW5hYmxlZGAgYW5kIGBzaGVwaGVyZC10YXJnZXRgIGNsYXNzIG5hbWVzIGFzIHdlbGwgYXMgdGhlIGBkYXRhLXNoZXBoZXJkLXN0ZXAtaWRgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnMgRGVmYXVsdCBvcHRpb25zIGZvciBTdGVwcyAoe0BsaW5rIFN0ZXAjY29uc3RydWN0b3J9KSwgY3JlYXRlZCB0aHJvdWdoIGBhZGRTdGVwYFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZXhpdE9uRXNjIEV4aXRpbmcgdGhlIHRvdXIgd2l0aCB0aGUgZXNjYXBlIGtleSB3aWxsIGJlIGVuYWJsZWQgdW5sZXNzIHRoaXMgaXMgZXhwbGljaXRseVxuICAgKiBzZXQgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24gTmF2aWdhdGluZyB0aGUgdG91ciB2aWEgbGVmdCBhbmQgcmlnaHQgYXJyb3cga2V5cyB3aWxsIGJlIGVuYWJsZWRcbiAgICogdW5sZXNzIHRoaXMgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuc3RlcHNDb250YWluZXIgQW4gb3B0aW9uYWwgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBzdGVwcy5cbiAgICogSWYgbm90IHNldCwgdGhlIHN0ZXBzIHdpbGwgYmUgYXBwZW5kZWQgdG8gYGRvY3VtZW50LmJvZHlgLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLm1vZGFsQ29udGFpbmVyIEFuIG9wdGlvbmFsIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgbW9kYWwuXG4gICAqIElmIG5vdCBzZXQsIHRoZSBtb2RhbCB3aWxsIGJlIGFwcGVuZGVkIHRvIGBkb2N1bWVudC5ib2R5YC5cbiAgICogQHBhcmFtIHtvYmplY3RbXSB8IFN0ZXBbXX0gb3B0aW9ucy5zdGVwcyBBbiBhcnJheSBvZiBzdGVwIG9wdGlvbnMgb2JqZWN0cyBvciBTdGVwIGluc3RhbmNlcyB0byBpbml0aWFsaXplIHRoZSB0b3VyIHdpdGhcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG91ck5hbWUgQW4gb3B0aW9uYWwgXCJuYW1lXCIgZm9yIHRoZSB0b3VyLiBUaGlzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIHRoZSB0b3VyJ3NcbiAgICogZHluYW1pY2FsbHkgZ2VuZXJhdGVkIGBpZGAgcHJvcGVydHkgLS0gd2hpY2ggaXMgYWxzbyBzZXQgb24gdGhlIGBib2R5YCBlbGVtZW50IGFzIHRoZSBgZGF0YS1zaGVwaGVyZC1hY3RpdmUtdG91cmAgYXR0cmlidXRlXG4gICAqIHdoZW5ldmVyIHRoZSB0b3VyIGJlY29tZXMgYWN0aXZlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMudXNlTW9kYWxPdmVybGF5IFdoZXRoZXIgb3Igbm90IHN0ZXBzIHNob3VsZCBiZSBwbGFjZWQgYWJvdmUgYSBkYXJrZW5lZFxuICAgKiBtb2RhbCBvdmVybGF5LiBJZiB0cnVlLCB0aGUgb3ZlcmxheSB3aWxsIGNyZWF0ZSBhbiBvcGVuaW5nIGFyb3VuZCB0aGUgdGFyZ2V0IGVsZW1lbnQgc28gdGhhdCBpdFxuICAgKiBjYW4gcmVtYWluIGludGVyYWN0aXZlXG4gICAqIEByZXR1cm5zIHtUb3VyfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICBhdXRvQmluZCh0aGlzKTtcblxuICAgIGNvbnN0IGRlZmF1bHRUb3VyT3B0aW9ucyA9IHtcbiAgICAgIGV4aXRPbkVzYzogdHJ1ZSxcbiAgICAgIGtleWJvYXJkTmF2aWdhdGlvbjogdHJ1ZVxuICAgIH07XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VG91ck9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2xhc3NQcmVmaXggPSBub3JtYWxpemVQcmVmaXgodGhpcy5vcHRpb25zLmNsYXNzUHJlZml4KTtcbiAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgdGhpcy5hZGRTdGVwcyh0aGlzLm9wdGlvbnMuc3RlcHMpO1xuXG4gICAgLy8gUGFzcyB0aGVzZSBldmVudHMgb250byB0aGUgZ2xvYmFsIFNoZXBoZXJkIG9iamVjdFxuICAgIGNvbnN0IGV2ZW50cyA9IFsnYWN0aXZlJywgJ2NhbmNlbCcsICdjb21wbGV0ZScsICdpbmFjdGl2ZScsICdzaG93JywgJ3N0YXJ0J107XG4gICAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IHtcbiAgICAgICgoZSkgPT4ge1xuICAgICAgICB0aGlzLm9uKGUsIChvcHRzKSA9PiB7XG4gICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgb3B0cy50b3VyID0gdGhpcztcbiAgICAgICAgICBTaGVwaGVyZC50cmlnZ2VyKGUsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NldFRvdXJJRCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBzdGVwIHRvIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0ZXB9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RlcCBvcHRpb25zIG9yIGEgU3RlcCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG9wdGlvbmFsIGluZGV4IHRvIGluc2VydCB0aGUgc3RlcCBhdC4gSWYgdW5kZWZpbmVkLCB0aGUgc3RlcFxuICAgKiBpcyBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7U3RlcH0gVGhlIG5ld2x5IGFkZGVkIHN0ZXBcbiAgICovXG4gIGFkZFN0ZXAob3B0aW9ucywgaW5kZXgpIHtcbiAgICBsZXQgc3RlcCA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgU3RlcCkpIHtcbiAgICAgIHN0ZXAgPSBuZXcgU3RlcCh0aGlzLCBzdGVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcC50b3VyID0gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGluZGV4KSkge1xuICAgICAgdGhpcy5zdGVwcy5zcGxpY2UoaW5kZXgsIDAsIHN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ZXA7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG11bHRpcGxlIHN0ZXBzIHRvIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0PiB8IEFycmF5PFN0ZXA+fSBzdGVwcyBUaGUgc3RlcHMgdG8gYWRkIHRvIHRoZSB0b3VyXG4gICAqL1xuICBhZGRTdGVwcyhzdGVwcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZXBzKSkge1xuICAgICAgc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byB0aGUgcHJldmlvdXMgc3RlcCBpbiB0aGUgdG91clxuICAgKi9cbiAgYmFjaygpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcbiAgICB0aGlzLnNob3coaW5kZXggLSAxLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgX2RvbmUoKSB0cmlnZ2VyaW5nIHRoZSAnY2FuY2VsJyBldmVudFxuICAgKiBJZiBgY29uZmlybUNhbmNlbGAgaXMgdHJ1ZSwgd2lsbCBzaG93IGEgd2luZG93LmNvbmZpcm0gYmVmb3JlIGNhbmNlbGxpbmdcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbmZpcm1DYW5jZWwpIHtcbiAgICAgIGNvbnN0IGNhbmNlbE1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgfHwgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzdG9wIHRoZSB0b3VyPyc7XG4gICAgICBjb25zdCBzdG9wVG91ciA9IHdpbmRvdy5jb25maXJtKGNhbmNlbE1lc3NhZ2UpO1xuICAgICAgaWYgKHN0b3BUb3VyKSB7XG4gICAgICAgIHRoaXMuX2RvbmUoJ2NhbmNlbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kb25lKCdjYW5jZWwnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgX2RvbmUoKSB0cmlnZ2VyaW5nIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLl9kb25lKCdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0ZXAgZnJvbSBhIGdpdmVuIGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBzdGVwIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBzdGVwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBpZGBcbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcy5maW5kKChzdGVwKSA9PiB7XG4gICAgICByZXR1cm4gc3RlcC5pZCA9PT0gaWQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdGVwXG4gICAqIEByZXR1cm5zIHtTdGVwfG51bGx9XG4gICAqL1xuICBnZXRDdXJyZW50U3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjdXJyZW50IHN0ZXBcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgY29uc3QgY3VycmVudFN0ZXAgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCk7XG5cbiAgICBpZiAoY3VycmVudFN0ZXApIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RlcC5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0b3VyIGlzIGFjdGl2ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPT09IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gdGhlIG5leHQgc3RlcCBpbiB0aGUgdG91clxuICAgKiBJZiB3ZSBhcmUgYXQgdGhlIGVuZCwgY2FsbCBgY29tcGxldGVgXG4gICAqL1xuICBuZXh0KCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KGluZGV4ICsgMSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHN0ZXAgZnJvbSB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaWQgZm9yIHRoZSBzdGVwIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlU3RlcChuYW1lKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKTtcblxuICAgIC8vIEZpbmQgdGhlIHN0ZXAsIGRlc3Ryb3kgaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoaXMuc3RlcHNcbiAgICB0aGlzLnN0ZXBzLnNvbWUoKHN0ZXAsIGkpID0+IHtcbiAgICAgIGlmIChzdGVwLmlkID09PSBuYW1lKSB7XG4gICAgICAgIGlmIChzdGVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgc3RlcC5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGVwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlkID09PSBuYW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHN0ZXBzIGxlZnQsIHNob3cgdGhlIGZpcnN0IG9uZSwgb3RoZXJ3aXNlIGp1c3QgY2FuY2VsIHRoZSB0b3VyXG4gICAgICB0aGlzLnN0ZXBzLmxlbmd0aCA/IHRoaXMuc2hvdygwKSA6IHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgYSBzcGVjaWZpYyBzdGVwIGluIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cCB0aGUgc3RlcCBieVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcndhcmQgVHJ1ZSBpZiB3ZSBhcmUgZ29pbmcgZm9yd2FyZCwgZmFsc2UgaWYgYmFja3dhcmRcbiAgICovXG4gIHNob3coa2V5ID0gMCwgZm9yd2FyZCA9IHRydWUpIHtcbiAgICBjb25zdCBzdGVwID0gaXNTdHJpbmcoa2V5KSA/IHRoaXMuZ2V0QnlJZChrZXkpIDogdGhpcy5zdGVwc1trZXldO1xuXG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdygpO1xuXG4gICAgICBjb25zdCBzaG91bGRTa2lwU3RlcCA9IGlzRnVuY3Rpb24oc3RlcC5vcHRpb25zLnNob3dPbikgJiYgIXN0ZXAub3B0aW9ucy5zaG93T24oKTtcblxuICAgICAgLy8gSWYgYHNob3dPbmAgcmV0dXJucyBmYWxzZSwgd2Ugd2FudCB0byBza2lwIHRoZSBzdGVwLCBvdGhlcndpc2UsIHNob3cgdGhlIHN0ZXAgbGlrZSBub3JtYWxcbiAgICAgIGlmIChzaG91bGRTa2lwU3RlcCkge1xuICAgICAgICB0aGlzLl9za2lwU3RlcChzdGVwLCBmb3J3YXJkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2hvdycsIHtcbiAgICAgICAgICBzdGVwLFxuICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmN1cnJlbnRTdGVwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBzdGVwO1xuICAgICAgICBzdGVwLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRvdXJcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcblxuICAgIC8vIFNhdmUgdGhlIGZvY3VzZWQgZWxlbWVudCBiZWZvcmUgdGhlIHRvdXIgb3BlbnNcbiAgICB0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IG51bGw7XG5cbiAgICB0aGlzLl9zZXR1cE1vZGFsKCk7XG5cbiAgICB0aGlzLl9zZXR1cEFjdGl2ZVRvdXIoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHRvdXIgaXMgY2FuY2VsbGVkIG9yIGNvbXBsZXRlZCwgYmFzaWNhbGx5IGFueXRpbWUgd2UgZXhpdCB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUgdG8gdHJpZ2dlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvbmUoZXZlbnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0ZXBzKSkge1xuICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiBzdGVwLmRlc3Ryb3koKSk7XG4gICAgfVxuXG4gICAgY2xlYW51cFN0ZXBzKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKGV2ZW50LCB7IGluZGV4IH0pO1xuXG4gICAgU2hlcGhlcmQuYWN0aXZlVG91ciA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VyKCdpbmFjdGl2ZScsIHsgdG91cjogdGhpcyB9KTtcblxuICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICB0aGlzLm1vZGFsLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdjYW5jZWwnIHx8IGV2ZW50ID09PSAnY29tcGxldGUnKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbCkge1xuICAgICAgICBjb25zdCBtb2RhbENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcicpO1xuXG4gICAgICAgIGlmIChtb2RhbENvbnRhaW5lcikge1xuICAgICAgICAgIG1vZGFsQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgdGhlIHRvdXIgc3RhcnRlZFxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRoaXMuZm9jdXNlZEVsQmVmb3JlT3BlbikpIHtcbiAgICAgIHRoaXMuZm9jdXNlZEVsQmVmb3JlT3Blbi5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgdG91ciBcImFjdGl2ZVwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBBY3RpdmVUb3VyKCkge1xuICAgIHRoaXMudHJpZ2dlcignYWN0aXZlJywgeyB0b3VyOiB0aGlzIH0pO1xuXG4gICAgU2hlcGhlcmQuYWN0aXZlVG91ciA9IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogX3NldHVwTW9kYWwgY3JlYXRlIHRoZSBtb2RhbCBjb250YWluZXIgYW5kIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBNb2RhbCgpIHtcbiAgICB0aGlzLm1vZGFsID0gbmV3IFNoZXBoZXJkTW9kYWwoe1xuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMubW9kYWxDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgIHByb3BzOlxuICAgICAge1xuICAgICAgICBjbGFzc1ByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCxcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGBzaG93T25gIGV2YWx1YXRlcyB0byBmYWxzZSwgdG8gc2tpcCB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgdG8gc2tpcFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcndhcmQgVHJ1ZSBpZiB3ZSBhcmUgZ29pbmcgZm9yd2FyZCwgZmFsc2UgaWYgYmFja3dhcmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9za2lwU3RlcChzdGVwLCBmb3J3YXJkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2Yoc3RlcCk7XG4gICAgY29uc3QgbmV4dEluZGV4ID0gZm9yd2FyZCA/IGluZGV4ICsgMSA6IGluZGV4IC0gMTtcbiAgICB0aGlzLnNob3cobmV4dEluZGV4LCBmb3J3YXJkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgc2hvd2luZywgaGlkZSB0aGUgY3VycmVudCBzdGVwIGFuZCBpZiB0aGUgdG91ciBpcyBub3RcbiAgICogYWxyZWFkeSBhY3RpdmUsIGNhbGwgYHRoaXMuX3NldHVwQWN0aXZlVG91cmAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RhdGVCZWZvcmVTaG93KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGVwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fc2V0dXBBY3RpdmVUb3VyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcy5pZCB0byBgJHt0b3VyTmFtZX0tLSR7dXVpZH1gXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VG91cklEKCkge1xuICAgIGNvbnN0IHRvdXJOYW1lID0gdGhpcy5vcHRpb25zLnRvdXJOYW1lIHx8ICd0b3VyJztcblxuICAgIHRoaXMuaWQgPSBgJHt0b3VyTmFtZX0tLSR7dXVpZCgpfWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiIsImltcG9ydCB7IFN0ZXAgfSBmcm9tICcuL3N0ZXAuanMnO1xuaW1wb3J0IHsgU2hlcGhlcmQsIFRvdXIgfSBmcm9tICcuL3RvdXIuanMnO1xuXG5PYmplY3QuYXNzaWduKFNoZXBoZXJkLCB7IFRvdXIsIFN0ZXAgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNoZXBoZXJkO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ })));